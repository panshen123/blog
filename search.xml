<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>==和equals的区别</title>
    <url>/2023/05/30/==%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="基本概念区分"><a href="#基本概念区分" class="headerlink" title="基本概念区分"></a>基本概念区分</h3><h4 id="1-对于-x3D-x3D-，比较的是值是否相等"><a href="#1-对于-x3D-x3D-，比较的是值是否相等" class="headerlink" title="1.对于&#x3D;&#x3D;，比较的是值是否相等"></a>1.对于&#x3D;&#x3D;，比较的是值是否相等</h4><p>如果作用于基本数据类型的变量，则直接比较其存储的 值是否相等，</p>
<p>如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等。</p>
<blockquote>
<p>其实&#x3D;&#x3D;比较的不管是基本数据类型，还是引用数据类型的变量，比较的都是值，只是引用类型变量存的值是对象的地址</p>
</blockquote>
<h4 id="2-对于equals方法，比较的是是否是同一个对象"><a href="#2-对于equals方法，比较的是是否是同一个对象" class="headerlink" title="2.对于equals方法，比较的是是否是同一个对象"></a>2.对于equals方法，比较的是是否是同一个对象</h4><p>首先，equals()方法不能作用于基本数据类型的变量，</p>
<p>另外，equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，所以说所有类中的equals()方法都继承自Object类，在没有重写equals()方法的类中，调用equals()方法其实和使用&#x3D;&#x3D;的效果一样，也是比较的是引用类型的变量所指向的对象的地址，不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。</p>
<p>Object类equals()方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有重写equals()方法的类中，调用equals()方法其实和使用&#x3D;&#x3D;的效果一样</p>
<p>String类中重写了equals()方法内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="1-实例1"><a href="#1-实例1" class="headerlink" title="1.实例1"></a>1.实例1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(x == y); <span class="comment">// true</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// false</span></span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="2-实例2"><a href="#2-实例2" class="headerlink" title="2.实例2"></a>2.实例2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>str3与str4相等的原因是用到了内存中的常量池，当运行到str3创建对象时，如果常量池中没有，就在常量池中创建一个对象”abc”，第二次创建的时候，就直接使用，所以两次创建的对象其实是同一个对象，它们的地址值相等。</p>
<h4 id="3-实例3"><a href="#3-实例3" class="headerlink" title="3.实例3"></a>3.实例3</h4><p>先定义学生Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwwhnly.springbootaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建两个Student实例来比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">23</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">23</span>);</span><br><span class="line">System.out.println(student1.equals(student2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>此时equals方法调用的是基类Object类的equals()方法，也就是&#x3D;&#x3D;比较，所以返回false。</p>
<p>然后我们重写下equals()方法，只要两个学生的年龄相同，就认为是同一个学生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwwhnly.springbootaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age == student.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时再比较刚刚的两个实例，返回true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">23</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">23</span>);</span><br><span class="line">System.out.println(student1.equals(student2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>基础面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之接口与抽象类的区别</title>
    <url>/2023/05/31/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="1、基本语法区别"><a href="#1、基本语法区别" class="headerlink" title="1、基本语法区别"></a>1、基本语法区别</h3><p>Java中接口和抽象类的定义语法分别为interface与abstract关键字。</p>
<p><strong>抽象类</strong>：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：</p>
<p>a、抽象类不能被实例化只能被继承；</p>
<p>b、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；</p>
<p>c、抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；</p>
<p>d、一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；</p>
<p>e、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。</p>
<p><strong>接口：</strong>Java中接口使用interface关键字修饰，特点为:</p>
<p>a、接口可以包含变量、方法；变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）；</p>
<p>b、接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p>
<p>c、一个类可以实现多个接口；</p>
<p>d、JDK1.8中对接口增加了新的特性：（1）、默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；（2）、静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。</p>
<p><strong>如下例子所示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">  <span class="comment">//JDK1.8</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码所示：</p>
<p>接口只能是功能的定义，而抽象类既可以为功能的定义也可以为功能的实现。</p>
<h3 id="2、面试题：接口与抽象类的区别"><a href="#2、面试题：接口与抽象类的区别" class="headerlink" title="2、面试题：接口与抽象类的区别"></a>2、面试题：接口与抽象类的区别</h3><p><strong>相同点</strong></p>
<p>（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p>
<p><strong>不同点</strong></p>
<p>（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</p>
<p>（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</p>
<p>（3）接口强调特定功能的实现，而抽象类强调所属关系。</p>
<p>（4）接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的String，StringBuilder，StringBuffer三者的区别</title>
    <url>/2023/05/30/Java%E4%B8%AD%E7%9A%84String%EF%BC%8CStringBuilder%EF%BC%8CStringBuffer%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>最近在学习Java的时候，遇到了这样一个问题，就是String,StringBuilder以及StringBuffer这三个类之间有什么区别呢，自己从网上搜索了一些资料，有所了解了之后在这里整理一下，便于大家观看，也便于加深自己学习过程中对这些知识点的记忆，如果哪里有误，恳请指正。</p>
<h4 id="这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。"><a href="#这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。" class="headerlink" title="这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。"></a>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。</h4><h4 id="一、首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder-gt-StringBuffer-gt-String"><a href="#一、首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder-gt-StringBuffer-gt-String" class="headerlink" title="一、首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String"></a>一、首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</h4><p>　　String最慢的原因：</p>
<p>​		String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。以下面一段代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">str=str+<span class="string">&quot;de&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>　　如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</p>
<p>　　而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</p>
<p>　　另外，有时候我们会这样对字符串进行赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;abc&quot;</span>+<span class="string">&quot;de&quot;</span>;</span><br><span class="line">StringBuilder stringBuilder=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;abc&quot;</span>).append(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>

<p>　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和</p>
<p>　　String str&#x3D;”abcde”;</p>
<p>　　是完全一样的，所以会很快，而如果写成下面这种形式</p>
<p>1 String str1&#x3D;”abc”;<br>2 String str2&#x3D;”de”;<br>3 String str&#x3D;str1+str2;<br>　　那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p>
<h4 id="二、再来说线程安全"><a href="#二、再来说线程安全" class="headerlink" title="二、再来说线程安全"></a>二、再来说线程安全</h4><p>　　在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</p>
<p>　　如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p>
<h4 id="三、总结一下"><a href="#三、总结一下" class="headerlink" title="三、总结一下"></a>三、总结一下</h4><p>String：适用于少量的字符串操作的情况</p>
<p>　　StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p>
<p>　　StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8 新特性</title>
    <url>/2023/05/30/JDK1.8%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="jdk1-8新特性知识点："><a href="#jdk1-8新特性知识点：" class="headerlink" title="jdk1.8新特性知识点："></a>jdk1.8新特性知识点：</h3><ul>
<li><strong>Lambda表达式</strong></li>
<li><strong>函数式接口</strong></li>
<li><strong>方法引用和构造器调用</strong></li>
<li><strong>Stream API</strong></li>
<li><strong>接口中的默认方法和静态方法</strong></li>
<li><strong>新时间日期API</strong></li>
</ul>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>lambda表达式本质上是一段匿名内部类，也可以是一段可以传递的代码</p>
<p>lambda最直观的优点：简洁代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(cpt);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt2 = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line">TreeSet&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(cpt2);</span><br></pre></td></tr></table></figure>

<p>Lmabda表达式的语法总结： () -&gt; ();</p>
<table>
<thead>
<tr>
<th>前置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>无参数无返回值</td>
<td>() -&gt; System.out.println(“Hello World”)</td>
</tr>
<tr>
<td>有一个参数无返回值</td>
<td>(x) -&gt; System.out.println(x)</td>
</tr>
<tr>
<td>有且只有一个参数无返回值</td>
<td>x -&gt; System.out.println(x)</td>
</tr>
<tr>
<td>有多个参数，有返回值，有多条lambda体语句</td>
<td>(x，y) -&gt; {System.out.println(“xxx”);return xxxx;}；</td>
</tr>
<tr>
<td>有多个参数，有返回值，只有一条lambda体语句</td>
<td>(x，y) -&gt; xxxx</td>
</tr>
</tbody></table>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>什么是函数式接口？<br>简单来说就是只定义了一个抽象方法的接口（Object类的public方法除外），就是函数式接口，并且还提供了注解：@FunctionalInterface</p>
<p>常见的四大函数式接口</p>
<p>Consumer <T>：消费型接口，有参无返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    changeStr(<span class="string">&quot;hello&quot;</span>,(str) -&gt; System.out.println(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Consumer&lt;T&gt; 消费型接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> con</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeStr</span><span class="params">(String str, Consumer&lt;String&gt; con)</span>&#123;</span><br><span class="line">    con.accept(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Supplier <T>：供给型接口，无参有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> getValue(() -&gt; <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Supplier&lt;T&gt; 供给型接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sup</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">(Supplier&lt;String&gt; sup)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sup.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Function &lt;T,R&gt;：函数式接口，有参有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> changeNum(<span class="number">100L</span>, (x) -&gt; x + <span class="number">200L</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Function&lt;T,R&gt; 函数式接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">changeNum</span><span class="params">(Long num, Function&lt;Long, Long&gt; fun)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun.apply(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Predicate<T>： 断言型接口，有参有返回值，返回值是boolean类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> changeBoolean(<span class="string">&quot;hello&quot;</span>, (str) -&gt; str.length() &gt; <span class="number">5</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Predicate&lt;T&gt; 断言型接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">changeBoolean</span><span class="params">(String str, Predicate&lt;String&gt; pre)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre.test(str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>若lambda体中的内容有方法已经实现了，那么可以使用“方法引用”<br>也可以理解为方法引用是lambda表达式的另外一种表现形式并且其语法比lambda表达式更加简单</p>
<p><strong>方法引用</strong><br>三种表现形式：</p>
<ol>
<li>对象：：实例方法名</li>
<li>类：：静态方法名</li>
<li>类：：实例方法名 （lambda参数列表中第一个参数是实例方法的调用 者，第二个参数是实例方法的参数时可用）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *注意：</span></span><br><span class="line"><span class="comment">       *   1.lambda体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的函数列表和返回值类型保持一致！</span></span><br><span class="line"><span class="comment">       *   2.若lambda参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用ClassName::method</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       Consumer&lt;Integer&gt; con = (x) -&gt; System.out.println(x);</span><br><span class="line">       con.accept(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 方法引用-对象::实例方法</span></span><br><span class="line">       Consumer&lt;Integer&gt; con2 = System.out::println;</span><br><span class="line">       con2.accept(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 方法引用-类名::静态方法名</span></span><br><span class="line">       BiFunction&lt;Integer, Integer, Integer&gt; biFun = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">       BiFunction&lt;Integer, Integer, Integer&gt; biFun2 = Integer::compare;</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> biFun2.apply(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 方法引用-类名::实例方法名</span></span><br><span class="line">       BiFunction&lt;String, String, Boolean&gt; fun1 = (str1, str2) -&gt; str1.equals(str2);</span><br><span class="line">       BiFunction&lt;String, String, Boolean&gt; fun2 = String::equals;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">result2</span> <span class="operator">=</span> fun2.apply(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">       System.out.println(result2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h5><p>格式：ClassName::new</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法引用  类名::new</span></span><br><span class="line">        Supplier&lt;Employee&gt; sup = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        System.out.println(sup.get());</span><br><span class="line">        Supplier&lt;Employee&gt; sup2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(sup2.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法引用 类名::new （带一个参数）</span></span><br><span class="line">        Function&lt;Integer, Employee&gt; fun = (x) -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(x);</span><br><span class="line">        Function&lt;Integer, Employee&gt; fun2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(fun2.apply(<span class="number">100</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h5><p>格式：Type[]::new</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 数组引用</span></span><br><span class="line">        Function&lt;Integer, String[]&gt; fun = (x) -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[x];</span><br><span class="line">        Function&lt;Integer, String[]&gt; fun2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">        String[] strArray = fun2.apply(<span class="number">10</span>);</span><br><span class="line">        Arrays.stream(strArray).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h4><p>Stream操作的三个步骤</p>
<ul>
<li>创建stream</li>
<li>中间操作（过滤、map）</li>
<li>终止操作</li>
</ul>
<h5 id="stream的创建："><a href="#stream的创建：" class="headerlink" title="stream的创建："></a>stream的创建：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1，校验通过Collection 系列集合提供的stream()或者paralleStream()</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Strean&lt;String&gt; stream1 = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过Arrays的静态方法stream()获取数组流</span></span><br><span class="line">String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">Stream&lt;String&gt; stream2 = Arrays.stream(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.通过Stream类中的静态方法of</span></span><br><span class="line">Stream&lt;String&gt; stream3 = Stream.of(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.创建无限流</span></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line">Stream&lt;Integer&gt; stream4 = Stream.iterate(<span class="number">0</span>,(x) -&gt; x+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成</span></span><br><span class="line">Stream.generate(() -&gt;Math.random());</span><br></pre></td></tr></table></figure>

<h5 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作:"></a>Stream的中间操作:</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 筛选 过滤  去重</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  emps.stream()</span><br><span class="line">          .filter(e -&gt; e.getAge() &gt; <span class="number">10</span>)</span><br><span class="line">          .limit(<span class="number">4</span>)</span><br><span class="line">          .skip(<span class="number">4</span>)</span><br><span class="line">          <span class="comment">// 需要流中的元素重写hashCode和equals方法</span></span><br><span class="line">          .distinct()</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  生成新的流 通过map映射</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  emps.stream()</span><br><span class="line">          .map((e) -&gt; e.getAge())</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  自然排序  定制排序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  emps.stream()</span><br><span class="line">          .sorted((e1 ,e2) -&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (e1.getAge().equals(e2.getAge()))&#123;</span><br><span class="line">                  <span class="keyword">return</span> e1.getName().compareTo(e2.getName());</span><br><span class="line">              &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> e1.getAge().compareTo(e2.getAge());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Stream的终止操作："><a href="#Stream的终止操作：" class="headerlink" title="Stream的终止操作："></a>Stream的终止操作：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        *      查找和匹配</span></span><br><span class="line"><span class="comment">        *          allMatch-检查是否匹配所有元素</span></span><br><span class="line"><span class="comment">        *          anyMatch-检查是否至少匹配一个元素</span></span><br><span class="line"><span class="comment">        *          noneMatch-检查是否没有匹配所有元素</span></span><br><span class="line"><span class="comment">        *          findFirst-返回第一个元素</span></span><br><span class="line"><span class="comment">        *          findAny-返回当前流中的任意元素</span></span><br><span class="line"><span class="comment">        *          count-返回流中元素的总个数</span></span><br><span class="line"><span class="comment">        *          max-返回流中最大值</span></span><br><span class="line"><span class="comment">        *          min-返回流中最小值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  检查是否匹配元素</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> emps.stream()</span><br><span class="line">               .allMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY));</span><br><span class="line">       System.out.println(b1);</span><br><span class="line"></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> emps.stream()</span><br><span class="line">               .anyMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY));</span><br><span class="line">       System.out.println(b2);</span><br><span class="line"></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> emps.stream()</span><br><span class="line">               .noneMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY));</span><br><span class="line">       System.out.println(b3);</span><br><span class="line"></span><br><span class="line">       Optional&lt;Employee&gt; opt = emps.stream()</span><br><span class="line">               .findFirst();</span><br><span class="line">       System.out.println(opt.get());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 并行流</span></span><br><span class="line">       Optional&lt;Employee&gt; opt2 = emps.parallelStream()</span><br><span class="line">               .findAny();</span><br><span class="line">       System.out.println(opt2.get());</span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> emps.stream()</span><br><span class="line">               .count();</span><br><span class="line">       System.out.println(count);</span><br><span class="line"></span><br><span class="line">       Optional&lt;Employee&gt; max = emps.stream()</span><br><span class="line">               .max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">       System.out.println(max.get());</span><br><span class="line"></span><br><span class="line">       Optional&lt;Employee&gt; min = emps.stream()</span><br><span class="line">               .min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">       System.out.println(min.get());</span><br></pre></td></tr></table></figure>

<h4 id="并行流和串行流"><a href="#并行流和串行流" class="headerlink" title="并行流和串行流"></a>并行流和串行流</h4><p>在jdk1.8新的stream包中针对集合的操作也提供了并行操作流和串行操作流。并行流就是把内容切割成多个数据块，并且使用多个线程分别处理每个数据块的内容。Stream api中声明可以通过parallel()与sequential()方法在并行流和串行流之间进行切换。<br>jdk1.8并行流使用的是fork&#x2F;join框架进行并行操作</p>
<h4 id="接口中可以定义默认实现方法和静态方法"><a href="#接口中可以定义默认实现方法和静态方法" class="headerlink" title="接口中可以定义默认实现方法和静态方法"></a>接口中可以定义默认实现方法和静态方法</h4><p>在接口中可以使用default和static关键字来修饰接口中定义的普通方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line">    <span class="keyword">default</span>  String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">getName2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在JDK1.8中很多接口会新增方法，为了保证1.8向下兼容，1.7版本中的接口实现类不用每个都重新实现新添加的接口方法，引入了default默认实现，static的用法是直接用接口名去调方法即可。当一个类继承父类又实现接口时，若后两者方法名相同，则优先继承父类中的同名方法，即“类优先”，如果实现两个同名方法的接口，则要求实现类必须手动声明默认实现哪个接口中的方法。</p>
<h4 id="新的日期API-LocalDate-LocalTime-LocalDateTime"><a href="#新的日期API-LocalDate-LocalTime-LocalDateTime" class="headerlink" title="新的日期API LocalDate | LocalTime | LocalDateTime"></a>新的日期API LocalDate | LocalTime | LocalDateTime</h4><p>新的日期API都是不可变的，更使用于多线程的使用环境中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 从默认时区的系统时钟获取当前的日期时间。不用考虑时区差</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">date</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">//2018-07-15T14:22:39.759</span></span><br><span class="line">    System.out.println(date);</span><br><span class="line"></span><br><span class="line">    System.out.println(date.getYear());</span><br><span class="line">    System.out.println(date.getMonthValue());</span><br><span class="line">    System.out.println(date.getDayOfMonth());</span><br><span class="line">    System.out.println(date.getHour());</span><br><span class="line">    System.out.println(date.getMinute());</span><br><span class="line">    System.out.println(date.getSecond());</span><br><span class="line">    System.out.println(date.getNano());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动创建一个LocalDateTime实例</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">date2</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">9</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line">    System.out.println(date2);</span><br><span class="line">    <span class="comment">// 进行加操作，得到新的日期实例</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">date3</span> <span class="operator">=</span> date2.plusDays(<span class="number">12</span>);</span><br><span class="line">    System.out.println(date3);</span><br><span class="line">    <span class="comment">// 进行减操作，得到新的日期实例</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">date4</span> <span class="operator">=</span> date3.minusYears(<span class="number">2</span>);</span><br><span class="line">    System.out.println(date4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 时间戳  1970年1月1日00：00：00 到某一个时间点的毫秒值</span></span><br><span class="line">    <span class="comment">// 默认获取UTC时区</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">ins</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    System.out.println(ins);</span><br><span class="line"></span><br><span class="line">    System.out.println(LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli());</span><br><span class="line">    System.out.println(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    System.out.println(Instant.now().toEpochMilli());</span><br><span class="line">    System.out.println(Instant.now().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant().toEpochMilli());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// Duration:计算两个时间之间的间隔</span></span><br><span class="line">    <span class="comment">// Period：计算两个日期之间的间隔</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">ins1</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Instant</span> <span class="variable">ins2</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    <span class="type">Duration</span> <span class="variable">dura</span> <span class="operator">=</span> Duration.between(ins1, ins2);</span><br><span class="line">    System.out.println(dura);</span><br><span class="line">    System.out.println(dura.toMillis());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime2</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">Duration</span> <span class="variable">du2</span> <span class="operator">=</span> Duration.between(localTime, localTime2);</span><br><span class="line">    System.out.println(du2);</span><br><span class="line">    System.out.println(du2.toMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span>LocalDate.now();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2016</span>,<span class="number">12</span>,<span class="number">12</span>);</span><br><span class="line">        <span class="type">Period</span> <span class="variable">pe</span> <span class="operator">=</span> Period.between(localDate, localDate2);</span><br><span class="line">        System.out.println(pe);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// temperalAdjust 时间校验器</span></span><br><span class="line">    <span class="comment">// 例如获取下周日  下一个工作日</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">ldt1</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(ldt1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一年中的第一天</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">ldt2</span> <span class="operator">=</span> ldt1.withDayOfYear(<span class="number">1</span>);</span><br><span class="line">    System.out.println(ldt2);</span><br><span class="line">    <span class="comment">// 获取一个月中的第一天</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">ldt3</span> <span class="operator">=</span> ldt1.withDayOfMonth(<span class="number">1</span>);</span><br><span class="line">    System.out.println(ldt3);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">ldt4</span> <span class="operator">=</span> ldt1.with(TemporalAdjusters.next(DayOfWeek.FRIDAY));</span><br><span class="line">    System.out.println(ldt4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个工作日</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">ldt5</span> <span class="operator">=</span> ldt1.with((t) -&gt; &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt6</span> <span class="operator">=</span> (LocalDateTime)t;</span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> ldt6.getDayOfWeek();</span><br><span class="line">        <span class="keyword">if</span> (DayOfWeek.FRIDAY.equals(dayOfWeek))&#123;</span><br><span class="line">            <span class="keyword">return</span> ldt6.plusDays(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (DayOfWeek.SATURDAY.equals(dayOfWeek))&#123;</span><br><span class="line">            <span class="keyword">return</span> ldt6.plusDays(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ldt6.plusDays(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(ldt5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// DateTimeFormatter: 格式化时间/日期</span></span><br><span class="line">    <span class="comment">// 自定义格式</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">strDate1</span> <span class="operator">=</span> ldt.format(formatter);</span><br><span class="line">    <span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> formatter.format(ldt);</span><br><span class="line">    System.out.println(strDate);</span><br><span class="line">    System.out.println(strDate1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用api提供的格式</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ISO_DATE;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">ldt2</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">strDate3</span> <span class="operator">=</span> dtf.format(ldt2);</span><br><span class="line">    System.out.println(strDate3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析字符串to时间</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">df</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">localTime</span> <span class="operator">=</span> df.format(time);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">ldt4</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2017-09-28 17:07:05&quot;</span>,df);</span><br><span class="line">    System.out.println(<span class="string">&quot;LocalDateTime转成String类型的时间：&quot;</span>+localTime);</span><br><span class="line">    System.out.println(<span class="string">&quot;String类型的时间转成LocalDateTime：&quot;</span>+ldt4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ZoneTime  ZoneDate       ZoneDateTime</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">    System.out.println(now);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now2</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> now2.atZone(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">    System.out.println(zdt);</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set = ZoneId.getAvailableZoneIds();</span><br><span class="line">    set.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<blockquote>
<p>表示日期的LocalDate<br>表示时间的LocalTime<br>表示日期时间的LocalDateTime</p>
</blockquote>
<p>新的日期API的几个优点：	</p>
<ul>
<li>之前使用的java.util.Date月份从0开始，我们一般会+1使用，很不方便，java.time.LocalDate月份和星期都改成了enum</li>
<li>java.util.Date和SimpleDateFormat都不是线程安全的，而LocalDate和LocalTime和最基本的String一样，是不变类型，不但线程安全，而且不能修改。</li>
<li>java.util.Date是一个“万能接口”，它包含日期、时间，还有毫秒数，更加明确需求取舍</li>
<li>新接口更好用的原因是考虑到了日期时间的操作，经常发生往前推或往后推几天的情况。用java.util.Date配合Calendar要写好多代码，而且一般的开发人员还不一定能写对。</li>
</ul>
<p>LocalDate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">localDateTest</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前日期,只含年月日 固定格式 yyyy-MM-dd    2018-05-04</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据年月日取日期，5月就是5，</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">oldDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据字符串取：默认格式yyyy-MM-dd，02不能写成2</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">yesteday</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2018-05-03&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是闰年 传入29号也会报错</span></span><br><span class="line">        LocalDate.parse(<span class="string">&quot;2018-02-29&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>LocalDate常用转化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日期转换常用,第一天或者最后一天...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">localDateTransferTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//2018-05-04</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="comment">// 取本月第1天： 2018-05-01</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">firstDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">    <span class="comment">// 取本月第2天：2018-05-02</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">secondDayOfThisMonth</span> <span class="operator">=</span> today.withDayOfMonth(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 取本月最后一天，再也不用计算是28，29，30还是31： 2018-05-31</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">    <span class="comment">// 取下一天：2018-06-01</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">firstDayOf2015</span> <span class="operator">=</span> lastDayOfThisMonth.plusDays(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 取2018年10月第一个周三 so easy?：  2018-10-03</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">thirdMondayOf2018</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2018-10-01&quot;</span>).with(TemporalAdjusters.firstInMonth(DayOfWeek.WEDNESDAY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LocalTime</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">localTimeTest</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//16:25:46.448(纳秒值)</span></span><br><span class="line">       <span class="type">LocalTime</span> <span class="variable">todayTimeWithMillisTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">       <span class="comment">//16:28:48 不带纳秒值</span></span><br><span class="line">       <span class="type">LocalTime</span> <span class="variable">todayTimeWithNoMillisTime</span> <span class="operator">=</span> LocalTime.now().withNano(<span class="number">0</span>);</span><br><span class="line">       <span class="type">LocalTime</span> <span class="variable">time1</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;23:59:59&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>LocalDateTime</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">localDateTimeTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//转化为时间戳  毫秒值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//时间戳转化为localdatetime</span></span><br><span class="line">        DateTimeFormatter df= DateTimeFormatter.ofPattern(<span class="string">&quot;YYYY-MM-dd HH:mm:ss.SSS&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(df.format(LocalDateTime.ofInstant(Instant.ofEpochMilli(time1),ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk版本特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7搭建自己的博客</title>
    <url>/2023/05/03/Service/</url>
    <content><![CDATA[<blockquote>
<p><strong>博客</strong>：其实博客的正式名称是网络日记，见名知意，是使用特定软件在网络上出版发表和张贴个人文章的人，或者是一种由个人管理不定期更新文章的网站。  </p>
</blockquote>
<p>现在是互联网逐渐发展，已经出现了很多可以供自己写博客的网站，大家可以在上面 发表自己的文章，供自己记录或者是供他人阅读。但是，可不可以自己搭建一个只属于自己的个人博客网站呢？这篇文章就带你从0开始搭建一个自己的个人博客网站，并部署到属于自己<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>。这里有一点要说的是，没有服务器的同学使用自己机器的linux系统也是一样的操作。我们选用一个很好用的博客框架Hexo进行搭建我们的个人博客。</p>
<h4 id="博客框架Hexo介绍："><a href="#博客框架Hexo介绍：" class="headerlink" title="博客框架Hexo介绍："></a>博客框架Hexo介绍：</h4><hr>
<p>Hexo是一个快速，简介而且高效的博客框架，Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可生成一个静态网页展示我们发布的文章，同时也提供了大量精美的博客主题供我们使用。</p>
<p><img src="/2023/03/03/Service/1.png"></p>
<h4 id="Hexo博客框架的优点"><a href="#Hexo博客框架的优点" class="headerlink" title="Hexo博客框架的优点"></a>Hexo博客框架的优点</h4><hr>
<ul>
<li>速度极快：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</li>
<li>支持MarkDown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</li>
<li>一键部署：只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台。</li>
<li>插件和可扩展性：这个也是hexo很强大的一个地方，强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less&#x2F;Sass）轻易集成</li>
</ul>
<h4 id="Hexo博客框架搭建："><a href="#Hexo博客框架搭建：" class="headerlink" title="Hexo博客框架搭建："></a><strong>Hexo博客框架搭建：</strong></h4><hr>
<p>我们使用Centos7系统作为演示，使用其他linux系统也是可以的，只需要更换为对应Linux版本的软件安装命令即可。</p>
<p>1.安装Git</p>
<p>直接使用yum安装即可，在命令行输入 yum -y install git</p>
<p>完成之后输入git version 查看是否安装成功，如果显示git版本信息即为成功，如下：</p>
<p><img src="/2023/03/03/Service/2.png"></p>
<p>2.安装Node.js</p>
<p>Node.js是一种运行在服务端的JavaScript，是一个基于Chrome JavaScript运行时建立的一个平台。</p>
<p>Hexo基于Node.js，所以安装Node.js是必须的一个操作，安装步骤如下：</p>
<p><strong>2.1：下载安装包：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">https</span>:<span class="comment">//nodejs.org/dist/v12.13.1/node-v12.13.1-linux-x64.tar.xz</span></span><br></pre></td></tr></table></figure>

<p><strong>2.2：解压缩软件包并配置环境变量：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#解压</span><br><span class="line">tar -xvJf node-v6<span class="number">.10</span><span class="number">.1</span>-linux-x64.<span class="property">tar</span>.<span class="property">xz</span></span><br><span class="line"></span><br><span class="line">#移动到/usl/lcoal目录下</span><br><span class="line">mv node-v6<span class="number">.10</span><span class="number">.1</span>-linux-x64 /usr/local/node-v6</span><br><span class="line"></span><br><span class="line">#创建软链接</span><br><span class="line">ln -s /usr/local/node-v6/bin/node /bin/node</span><br><span class="line">ln -s /usr/local/node-v6/bin/npm /bin/npm</span><br><span class="line"></span><br><span class="line">#添加环境变量</span><br><span class="line">echo <span class="string">&#x27;export PATH=/usr/local/node-v6/bin:$PATH&#x27;</span> &gt;&gt; <span class="regexp">/etc/</span>profile</span><br><span class="line">source /etc/profile  #让环境变量生效</span><br></pre></td></tr></table></figure>

<p><strong>2.3：测试是否安装成功：</strong></p>
<p>在命令行输入node -v 和 npm -v，若是显示出了版本号，即为安装成功：</p>
<p><img src="/2023/03/03/Service/3.png"></p>
<p><strong>3.安装并使用Hexo</strong></p>
<p>Hexo的安装较为简单，使用如下命令安装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">#这里有一点要注意的就是，npm的源是在国外的，访问可能会很慢，这里可以换成我们国内的源进行安装加快速度。操作如下：</span><br><span class="line">npm config set registry <span class="attr">https</span>:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/03/Service/4.png"></p>
<p><strong>3.1：初始化Hexo</strong></p>
<p>上面的安装完成之后执行下面的命令进行对Hexo进行一个初始化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#这个文件名字可以自己指定，之后会在当前目录下生成对应文件夹</span><br><span class="line">hexo init &lt;文件名字&gt;</span><br><span class="line">cd 文件名字</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>可以看到安装好之后的一个目录结构：</p>
<p><img src="/2023/03/03/Service/5.png"></p>
<p><strong>目录文件说明：</strong></p>
<p>_config.yml：网站的配置信息，您可以在此配置大部分的参数。</p>
<p>package.json：应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p>
<p>scaffolds：模版文件夹。当您新建文章时Hexo 会根据 scaffold 来建立文件Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold&#x2F;post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<p>source：资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p>
<p>themes：主题 文件夹。Hexo 会根据主题来生成静态页面。</p>
<p>查看hexo的版本以及对应的数据：</p>
<p><img src="/2023/03/03/Service/6.png"></p>
<p><strong>3.2生成静态文件，并开启Hexo服务：</strong></p>
<p>进入到了hexo的安装目录之后，使用hexo generate来生成静态文件，也可以使用hexo g，之后使用hexo server（可以写成hexo s）命令启动服务，操作如下：</p>
<p><img src="/2023/03/03/Service/7.png"></p>
<p>可以看到4000端口的服务已经开启，之后在你的浏览器输入http:&#x2F;&#x2F;&lt;你的linux机器的ip地址或者服务器公网地址&gt;:4000,如下可以看到最开始的一个界面：</p>
<p><img src="/2023/03/03/Service/8.png"></p>
<p><strong>4.初步使用Hexo：</strong></p>
<hr>
<p>使用前，我们对我们的站点进行一个配置，也就是我们创建的hexo目录的_config.yml文件，可以修改的部分介绍如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># <span class="title class_">Site</span></span><br><span class="line"><span class="attr">title</span>: <span class="variable constant_">QIMING</span>.<span class="property">INFO</span> #博客网站的标题</span><br><span class="line"><span class="attr">subtitle</span>:          #博客网站的副标题</span><br><span class="line"><span class="attr">description</span>:       #你的网站描述</span><br><span class="line"><span class="attr">keywords</span>:          #网站的关键词  </span><br><span class="line"><span class="attr">author</span>:            #作者的名字</span><br><span class="line"><span class="attr">language</span>:          #博客网站使用的语言</span><br><span class="line"><span class="attr">timezone</span>:          #网站时区</span><br></pre></td></tr></table></figure>

<p>我自己的修改如下供大家参考，这里的修改没有太大的限制：</p>
<p><img src="/2023/03/03/Service/9.png"></p>
<p><strong>4.1：开始使用Hexo发布自己的第一篇博客！</strong></p>
<p>执行下面的目录创建一篇新文章：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> post &lt;文章标题&gt;</span><br></pre></td></tr></table></figure>

<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9Tz5aBlT-1622032930755)(pictures&#x2F;image-20210526145922392.png)]</p>
<p>这里我创建了一篇标题为First_Blog的博客，创建之后hexo目录下面的source&#x2F;_post文件夹下会产生一个First_Blog.md的文件</p>
<p><strong>4.2:编辑文章</strong></p>
<p>进入到上面说的那个目录下可以看到我们创建的博客文件：</p>
<p><img src="/2023/03/03/Service/10.png"></p>
<p>直接使用vim或者vi就可以对我们的博客文章进行编辑了，打开此First_Blog.md后可以看到—分隔的区域，这部分主要对文章进行标注变量，如下：</p>
<p><img src="/2023/03/03/Service/11.png"></p>
<p><strong>title</strong>：标题</p>
<p><strong>tage</strong>：标签</p>
<p><strong>categories</strong>：分类</p>
<p><strong>date</strong>：时间</p>
<p>这些标注大家在—–区域可以进行使用</p>
<p><strong>4.3：发布文章</strong></p>
<p>输入如下命令，生成静态网页，静态网页会存放在public文件下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo  g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>之后就可以去浏览器访问了！可以看到我们发布的文章已经成功在浏览器显示，到这里个人博客网站就已经成功搭建了。</p>
<p><img src="/2023/03/03/Service/12.png"></p>
<p><strong>5.主题的选择：</strong></p>
<p>主题网站：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a> hexo提供了大量精美的主题供我们选择，选择喜欢的主题，在<strong>hexo</strong>目录下的<strong>themes</strong>文件夹下使用git clone下载主题，之后再配置文件_config.yml把theme后面修改成下载的主题的名字，之后运行hexo clean ，hexo g即可看到生效的主题。</p>
<p><img src="/2023/03/03/Service/13.png"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>从零开始搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-security框架学习day01</title>
    <url>/2023/06/05/Spring-security%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1.整体架构"></a>1.整体架构</h3><h4 id="1-认证authentication"><a href="#1-认证authentication" class="headerlink" title="(1)认证	authentication"></a>(1)认证	authentication</h4><h4 id="2-授权authorization"><a href="#2-授权authorization" class="headerlink" title="(2)授权	authorization"></a>(2)授权	authorization</h4><h3 id="2-认证"><a href="#2-认证" class="headerlink" title="2.认证"></a>2.认证</h3><p>​	(1)AuthenticationManager</p>
<p>​		在Spring Sercurity中认证是由AuthenticationManager接口来负责的，接口定义为</p>
<p>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationManager</span>&#123;</span><br><span class="line">	Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationManager</span>&#123;</span><br><span class="line">	Authentication <span class="title function_">authentication</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*返回Authentication表示认证成功</p>
<p>*返回AuthenticationException异常，表示认证失败</p>
<p>AuthenticationManager 主要实现类为ProviderManager，在ProvideManager中管理了众多的AuthenticationProvider实例。在一次完整认证流程中，Spring Sercutiry允许存在多个AuthenticationProvider，用来实现多种认证方式，这些AuthenticaitionProvider都是由ProviderManager进行统一管理的。</p>
<p>(2)Authentication</p>
<p>​	拿取用户信息可以使用Authentication接口</p>
<p>​	认证以及认证成功的信息主要是由Authentication的实现类进行保存的，其接口定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Authentication</span> <span class="keyword">extends</span> <span class="title class_">Principal</span>,Serizlizable&#123;</span><br><span class="line">	Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities(); <span class="comment">//获取权限信息</span></span><br><span class="line">	Object <span class="title function_">getCredentials</span><span class="params">()</span>; <span class="comment">//获取密码信息</span></span><br><span class="line">	Object <span class="title function_">getDetails</span><span class="params">()</span>;	<span class="comment">//获取用户身份详细信息</span></span><br><span class="line">	Object <span class="title function_">getPrincipal</span><span class="params">()</span>;	<span class="comment">//获取用户身份</span></span><br><span class="line">	Boolean <span class="title function_">isAuthenticated</span><span class="params">()</span>; 	<span class="comment">//判断是否认证</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegaArgumentException <span class="comment">//设置认证标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)SercurityContextHolder</p>
<p>​	SercurityContextHolder用来获取登陆之后用户信息。Spring secyrity会将登陆用户数据保存在Session中。但是为了使用方便，Spring Security在此基础上还做了一些改进，其中最主要的一个变化就是线程绑定。当前用户登陆成功后，Spring Security会讲登陆成功的数据信息保存在SercurityContextHolder中。SecurityContextHolder中的数据保存默认通过ThreadLocal来实现的，是使用ThreadLocal创建的变量只能被当前线程所访问，不能被其他线程访问和修改，也就是将SecurityContextHolder中的数据拿出来保存到session中，同时将SecurityContextHolder中的数据清空。以后每当有请求来时，Spring Security就会先从session中取出用户登陆数据，保存到SecurityContextHolder中，方便在该请求的后续处理过程当中使用，同时在请求结束的时候将SecurityContextHolder中的数据拿出来保存到session中，然后将SecurityContextHolder中的数据清空。这一策略非常方便用户在Controller、Sercive层以及任何代码中获取当前登陆用户数据。</p>
<h3 id="3-授权"><a href="#3-授权" class="headerlink" title="3.授权"></a>3.授权</h3><p>​	当完成认证后，接下来就是授权。在Spring Security的授权体系中，有两个关键接口</p>
<p>​	(1)AccessDecisionManager</p>
<p>​	访问决策管理器，用来决定此次访问是否被允许。</p>
<p>​	(2)AccessDecisionVoter</p>
<p>​	访问决定投票器，投票器会检查用户是否具备应有的角色，进而投出赞成、反对或者弃权票。</p>
<p>​	(3)ConfigAttribute</p>
<p>​	用来保存授权时的角色信息</p>
]]></content>
      <categories>
        <category>spring-security</category>
      </categories>
      <tags>
        <tag>安全框架</tag>
      </tags>
  </entry>
  <entry>
    <title>java之异常（Exception）与错误（Error）的区别</title>
    <url>/2023/05/31/java%E4%B9%8B%E5%BC%82%E5%B8%B8%EF%BC%88Exception%EF%BC%89%E4%B8%8E%E9%94%99%E8%AF%AF%EF%BC%88Error%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Error（错误）:程序无法处理，通常指程序中出现的严重问题。</p>
<p>例如java.lang.VirtualMachineError（Java虚拟机运行错误）：当 Java虚拟机崩溃或用尽了它继续操作所需的资源时，抛出该错误<br>例如java.lang.StackOverflowError（栈溢出错误）：当应用程序递归太深而发生堆栈溢出时，抛出该错误。<br>例如java.lang.OutOfMemoryError（内存溢出）：内存溢出或没有可用的内存提供给垃圾回收器时，产生这个错误。<br>Error（错误）是不可查的，而且也常常在应用程序的控制和处理能力之外，因此当Error（错误）出现时，程序会立即奔溃，Java虚拟机立即停止运行，<br>Exception（异常）:是指程序本身可以处理的异常（可以向上抛出或者捕获处理）。</p>
<p>Java处理异常的默认方式是中断处理。</p>
<p>以java.lang.NullPointerException为例，当程序出现空指针异常时，会创建一个空指针异常对象，并向外抛出，并被虚拟机捕获，从而导致程序中断执行。</p>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p><img src="https://tu.hanxi.fun/images/3252ed12a74e511e96c197fffef2ea0.png"></p>
<p>Exception（异常）分为两大类：运行异常和编译异常。</p>
<ol>
<li>运行异常：顾名思义，是程序运行时才会出现的异常。运行异常是java.lang.RuntimeException类及其子类的统称。如NullPointerException（空指针异常）、IndexOutOfBoundsException（数组下标越界异常）等。运行异常一般是由程序逻辑错误导致的，可以通过捕获处理或向上抛出。运行异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现运行异常，也会被编译通过。</li>
<li>编译异常：顾名思义，是程序编译时就会出现的异常。编译异常是java.lang.RuntimeException以外的异常。编译异常必须进行处理，如果不处理，程序就不能编译通过。</li>
</ol>
<h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<h3 id="try…catch…finally-捕获异常并处理"><a href="#try…catch…finally-捕获异常并处理" class="headerlink" title="try…catch…finally : 捕获异常并处理"></a>try…catch…finally : 捕获异常并处理</h3><p><strong>面试题</strong>： 如果try{} 里有一个 return 语句，那么finalfly{} 里的代码会不会被执行，什么时候被执行，在 return 前还是后?</p>
<p>会执行，在return前执行。当程序检测到try{}中的return语句时，它会在return语句执行前，检查是否finalfly{}语句，如果有，就执行finalfly{}语句，如果没有，直接返回。如果finalfly{}里也有return 语句，那么try{}中的return语句将失效。</p>
<h3 id="throw：抛出异常"><a href="#throw：抛出异常" class="headerlink" title="throw：抛出异常"></a>throw：抛出异常</h3><h3 id="throws：声明异常"><a href="#throws：声明异常" class="headerlink" title="throws：声明异常"></a>throws：声明异常</h3><p><strong>声明异常</strong>：声明一个异常，并告知调用者。关键字throws运用于<strong>方法声明</strong>上，表示当前方法<strong>不处理异常</strong>，而是提醒该方法的调用者来处理异常(<strong>捕获处理或者继续抛出</strong>)。</p>
<ul>
<li>如果方法内部throw一个<strong>编译异常</strong>，而<strong>没有捕获处理</strong>，那么<strong>必须</strong>在方法体上通过<strong>throws</strong>进行声明，让<strong>调用者处理</strong>。</li>
</ul>
<p>补充：</p>
<p>运行时异常被抛出，调用者可以不处理，那么就会由jvm处理。</p>
<p>如果finally{}语句块中有return语句，那么会永远返回finally中的结果。</p>
<p>如果父类方法抛出多个异常，那么子类重写父类方法时，可以选择抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
<p>如果父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射特性</title>
    <url>/2023/05/31/java%E5%8F%8D%E5%B0%84%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<p>Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；<br>Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；<br>Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。</p>
<h3 id="反射的优点："><a href="#反射的优点：" class="headerlink" title="反射的优点："></a>反射的优点：</h3><p><strong>可扩展性 ：</strong>应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</p>
<p><strong>类浏览器和可视化开发环境 ：</strong>一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</p>
<p><strong>调试器和测试工具 ：</strong> 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</p>
<h3 id="反射的缺点："><a href="#反射的缺点：" class="headerlink" title="反射的缺点："></a>反射的缺点：</h3><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<p><strong>性能开销 ：</strong>反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p>
<p><strong>安全限制 ：</strong>使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p>
<p><strong>内部暴露 ：</strong>由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础学习day10</title>
    <url>/2023/03/03/java%E5%AD%A6%E4%B9%A0%E7%AC%AC10%E5%A4%A9/</url>
    <content><![CDATA[<h4 id="1-线程的创建方式（第一种用继承类方式实现多线程）"><a href="#1-线程的创建方式（第一种用继承类方式实现多线程）" class="headerlink" title="1.线程的创建方式（第一种用继承类方式实现多线程）"></a>1.线程的创建方式（第一种用继承类方式实现多线程）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多线程</span></span><br><span class="line"><span class="comment">        1.什么是进程，什么是线程？</span></span><br><span class="line"><span class="comment">        进程是一个应用程序（1个进程是一个软件）</span></span><br><span class="line"><span class="comment">        线程是一个进程中的执行场景\执行单元。</span></span><br><span class="line"><span class="comment">        一个进程可以启动多个线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2.对于java程序来说，当在Dos命令窗口中输入：</span></span><br><span class="line"><span class="comment">        java HelloWorld回车之后</span></span><br><span class="line"><span class="comment">        会先启动JVM，而JVM就是一个进程。</span></span><br><span class="line"><span class="comment">        JVM再启动一个主线程调用main方法</span></span><br><span class="line"><span class="comment">        同时在启动一个垃圾回收线程负责看护回收垃圾。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：进程A和进程B的内存独立不共享。</span></span><br><span class="line"><span class="comment">            线程A和线程B</span></span><br><span class="line"><span class="comment">                在java语言中:</span></span><br><span class="line"><span class="comment">                线程A和线程B，堆内存和方法区内存共享</span></span><br><span class="line"><span class="comment">                但是栈内存独立，一个线程一个栈</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    java语言中，实现线程有两种方式</span></span><br><span class="line"><span class="comment">        第一种方式：编写一个类，直接继承java.lang.Thread,重写run方法</span></span><br><span class="line"><span class="comment">        创建线程对象</span></span><br><span class="line"><span class="comment">        启动线程</span></span><br><span class="line"><span class="comment">        第二种方式:编写一个类，实现java.lang.Runnable接口,实现run方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里是main方法，这里的代码属于主线程，在主栈中运行。</span></span><br><span class="line">        <span class="comment">//新建一个分支线程对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        myThread.start();<span class="comment">//start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后，瞬间结束了</span></span><br><span class="line">        <span class="comment">//  这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开出来，start()方法就结束了，线程就启动成功了。</span></span><br><span class="line">        <span class="comment">//启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部(压栈)</span></span><br><span class="line">        <span class="comment">//run方法在分支栈的底部，main方法在主栈的底部，run和main是平级的。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程-----&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个类，直接继承java.lang.Thread,重写run方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//编写程序，这段程序运行在分支线程中（分支栈）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分支线程------&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-用接口的方式实现多线程（推荐）"><a href="#2-用接口的方式实现多线程（推荐）" class="headerlink" title="2.用接口的方式实现多线程（推荐）"></a>2.用接口的方式实现多线程（推荐）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现线程的第二种方法，编写一个类实现java.lang.Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个可运行的对象</span></span><br><span class="line"><span class="comment">//        MyRunnable myRunnable = new MyRunnable();</span></span><br><span class="line">        <span class="comment">//将可运行的对象封装成一个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());<span class="comment">//代码合并</span></span><br><span class="line">        <span class="comment">//启动线程对象</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程-------&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分支线程输出----&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础学习day01</title>
    <url>/2023/03/03/java%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E5%A4%A9/</url>
    <content><![CDATA[<h4 id="1-第一个程序"><a href="#1-第一个程序" class="headerlink" title="1.第一个程序"></a>1.第一个程序</h4><p>​	<strong>输入一个三位数，分别打印输出这个数的个位，十位，百位。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个数字:&quot;</span>);</span><br><span class="line">        <span class="comment">//输入一个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="comment">//输入数字的个位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> number%<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">shi</span> <span class="operator">=</span> number/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bai</span> <span class="operator">=</span> number/<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;个位数字是:&quot;</span>+ge);</span><br><span class="line">        System.out.println(<span class="string">&quot;十位数字是:&quot;</span>+shi);</span><br><span class="line">        System.out.println(<span class="string">&quot;百位数字是:&quot;</span>+bai);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-第二个程序"><a href="#2-第二个程序" class="headerlink" title="2.第二个程序"></a>2.第二个程序</h4><p> +&#x3D;、-&#x3D;、&#x2F;&#x3D;、*&#x3D;、%&#x3D;  <strong>等运算符的练习</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//+=</span></span><br><span class="line">        <span class="comment">//将左边的数和右边的数相加，在将得到的值赋值给左边</span></span><br><span class="line">        <span class="comment">//细节:</span></span><br><span class="line">        <span class="comment">//+=、-=、/=、*=、%= 底层隐藏了一个强制类型转换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        a+=b;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="comment">//-=</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        c-=d;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        <span class="comment">//*=</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        e*=f;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="comment">// /=</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(g);</span><br><span class="line">        g/=h;</span><br><span class="line">        System.out.println(g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-第三个程序"><a href="#3-第三个程序" class="headerlink" title="3.第三个程序"></a>3.第三个程序</h4><p>​	<strong>用&#x3D;&#x3D;号判断两遍是否相等</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.==判断左右两遍是否相等</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(a==b);</span><br><span class="line">        System.out.println(a==c);</span><br><span class="line">        System.out.println(c==b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-第四个程序"><a href="#4-第四个程序" class="headerlink" title="4.第四个程序"></a>4.第四个程序</h4><p>​	<strong>与或非运算符的用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">d</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        System.out.println(a==b&amp;c&gt;b);</span><br><span class="line">        System.out.println(a==c&amp;c&gt;b);</span><br><span class="line">        System.out.println(a&gt;c|c&gt;b);</span><br><span class="line">        System.out.println(b&gt;c|c&lt;a);</span><br><span class="line">        System.out.println(<span class="literal">false</span>^<span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="literal">false</span>^<span class="literal">true</span>);</span><br><span class="line">        System.out.println(!d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-第五个程序"><a href="#5-第五个程序" class="headerlink" title="5.第五个程序"></a>5.第五个程序</h4><p>​	<strong>短路运算符的用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//短路运算符，先判断左边的条件是否成立，如果成立则继续判断下一个条件，如果不成立，则直接结束。</span></span><br><span class="line">        <span class="comment">//1.&amp;&amp;短路与（先判断第一个条件是否成立）</span></span><br><span class="line">        System.out.println(<span class="literal">false</span>&amp;&amp;<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="literal">true</span>&amp;&amp;<span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="literal">true</span>&amp;&amp;<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//2.||短路或（先判定第一个条件是否成立）</span></span><br><span class="line">        System.out.println(<span class="literal">false</span>||<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="literal">true</span>||<span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="literal">false</span>||<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-第六个程序"><a href="#6-第六个程序" class="headerlink" title="6.第六个程序"></a>6.第六个程序</h4><p>​	<strong>利用三元运算符判断最大值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//利用三元运算符判断最大值</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请在输入一个数&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a &gt; b ? a:b;</span><br><span class="line">        System.out.println(<span class="string">&quot;两个数的最大值是:&quot;</span>+max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-第七个程序"><a href="#7-第七个程序" class="headerlink" title="7.第七个程序"></a>7.第七个程序</h4><p>​	<strong>利用三元运算符判断两只老虎的体重是否相同</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第一个老虎的体重&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tiger</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第二个老虎的体重&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tiger1</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"><span class="comment">//        System.out.println(tiger==tiger1);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tiger2</span> <span class="operator">=</span> tiger==tiger1?<span class="string">&quot;相同&quot;</span>:<span class="string">&quot;不同&quot;</span>;</span><br><span class="line">        System.out.println(tiger2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-第八个程序"><a href="#8-第八个程序" class="headerlink" title="8.第八个程序"></a>8.第八个程序</h4><p>​	<strong>利用三元运算符的嵌套判断三个和尚中最高的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//三个和尚分别高 150、210、165</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">150</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">210</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">165</span>;</span><br><span class="line">        System.out.println(a&gt;b?(a&gt;c?a:c):(b&gt;c?b:c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个课后作业："><a href="#两个课后作业：" class="headerlink" title="两个课后作业："></a>两个课后作业：</h2><h4 id="1-第一个作业"><a href="#1-第一个作业" class="headerlink" title="1.第一个作业"></a>1.第一个作业</h4><h5 id="输入男士和女士衣服的时髦度，如果男士大于女士的则打印相亲成功，否则相亲失败"><a href="#输入男士和女士衣服的时髦度，如果男士大于女士的则打印相亲成功，否则相亲失败" class="headerlink" title="输入男士和女士衣服的时髦度，如果男士大于女士的则打印相亲成功，否则相亲失败"></a><strong>输入男士和女士衣服的时髦度，如果男士大于女士的则打印相亲成功，否则相亲失败</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeWork</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入男士衣服的时髦度&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">boy</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入女士的衣服时髦度&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">gril</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (boy&gt;gril)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;相亲成功!!!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;相亲失败!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-第二个作业"><a href="#2-第二个作业" class="headerlink" title="2.第二个作业"></a>2.第二个作业</h4><p>​	<strong>输入一个数字，判断这个数字是否等于6或者相加可以让6整除的返回true，否则返回false</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeWork1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请在输入一个数字&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">number1</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(number==<span class="number">6</span>||number1==<span class="number">6</span>||(number+number1)%<span class="number">6</span>==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础学习day11</title>
    <url>/2023/03/03/java%E5%AD%A6%E4%B9%A0%E7%AC%AC11%E5%A4%A9/</url>
    <content><![CDATA[<h4 id="1-线程的Sleep方法"><a href="#1-线程的Sleep方法" class="headerlink" title="1.线程的Sleep方法"></a>1.线程的Sleep方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----&gt;&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.getMessage();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-如何终止线程睡眠"><a href="#2-如何终止线程睡眠" class="headerlink" title="2.如何终止线程睡眠"></a>2.如何终止线程睡眠</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    终止正在睡眠的线程</span></span><br><span class="line"><span class="comment">    不是终止线程，是终止线程的睡眠</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终断睡眠，唤醒线程</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----&gt;start&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">365</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----&gt;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-如何强制终止线程（第一种方式）"><a href="#3-如何强制终止线程（第一种方式）" class="headerlink" title="3.如何强制终止线程（第一种方式）"></a>3.如何强制终止线程（第一种方式）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.plaf.TableHeaderUI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    强行终止一个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread1</span>());</span><br><span class="line">        thread.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//强行终止线程t</span></span><br><span class="line">        thread.stop();<span class="comment">//已过时，不建议使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----&gt;&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-如何强制终止线程（第二种方式）【推荐使用第二种】"><a href="#3-如何强制终止线程（第二种方式）【推荐使用第二种】" class="headerlink" title="3.如何强制终止线程（第二种方式）【推荐使用第二种】"></a>3.如何强制终止线程（第二种方式）【推荐使用第二种】</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.plaf.TableHeaderUI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    怎么合理的终止一个线程的执行</span></span><br><span class="line"><span class="comment">    常用方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread2);</span><br><span class="line">        thread.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程，什么时候想结束线程，把标记改为false</span></span><br><span class="line">        myThread2.run =<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (run)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//需要保存的数据在这里保存即可</span></span><br><span class="line">                <span class="comment">//终止当前线程</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础学习day02</title>
    <url>/2023/03/03/java%E5%AD%A6%E4%B9%A0%E7%AC%AC2%E5%A4%A9/</url>
    <content><![CDATA[<h4 id="1-数组的小练习"><a href="#1-数组的小练习" class="headerlink" title="1.数组的小练习"></a>1.数组的小练习</h4><p>​	<strong>java中新建数组的语法</strong></p>
<p>​	<strong>int [] arr &#x3D; {1,2,3,4,5}	(数组的静态初始化)</strong></p>
<p>​	<strong>int [] arr &#x3D; new int [10]	(数组的动态初始化)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//存储四个数字,并打印</span></span><br><span class="line">        <span class="type">int</span> [] array =<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;array.length ; i++) &#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存数五个学生的年龄,并打印</span></span><br><span class="line">        <span class="type">int</span> [] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>,<span class="number">21</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;array1.length ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个学生的年龄是:&quot;</span>+array1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存放四个学生的身高，并打印</span></span><br><span class="line">        <span class="type">int</span> [] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">187</span>,<span class="number">164</span>,<span class="number">159</span>,<span class="number">186</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;array2.length ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个学生的身高是:&quot;</span>+array2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-抽象方法"><a href="#2-抽象方法" class="headerlink" title="2.抽象方法"></a>2.抽象方法</h4><h5 id="抽象方法的特点："><a href="#抽象方法的特点：" class="headerlink" title="抽象方法的特点："></a>抽象方法的特点：</h5><p><strong>特点1：没有方法体，以封号结尾</strong></p>
<p><strong>特点2：前面修饰符列表中有abstract关键字</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">/**抽象方法</span></span><br><span class="line"><span class="comment">        public abstract void doSome();</span></span><br><span class="line"><span class="comment">       特点1：没有方法体，以封号结尾</span></span><br><span class="line"><span class="comment">       特点2：前面修饰符列表中有abstract关键字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        抽象类中不一定有抽象方法</span></span><br><span class="line"><span class="comment">        但抽象方法必须出现在抽象类中</span></span><br><span class="line"><span class="comment">        抽象类的子类可以是抽象类，也可以是非抽象类</span></span><br><span class="line"><span class="comment">        抽象类无法实例化，但抽象类有构造方法。这个构造</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        一个非抽象类继承抽象类，必须将抽象类中的抽象方法实现。</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">       <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-接口"><a href="#3-接口" class="headerlink" title="3.接口"></a>3.接口</h4><p><strong>1.接口也是一种引用数据类型<br>2.接口是完全抽象的。（抽象类是半抽象），或者可以说接口是特殊的抽象类<br>3.接口怎么定义，语法是什么？					public interface 接口名{}<br>4.接口编译之后也是一个字节码文件.class<br>5.接口支持多继承，一个接口允许继承多个接口<br>6.接口中只包含两部分内容，一部分是：常量。一部分是：抽象方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            接口：</span></span><br><span class="line"><span class="comment">                1.接口也是一种引用数据类型</span></span><br><span class="line"><span class="comment">                2.接口是完全抽象的。（抽象类是半抽象），或者可以说接口是特殊的抽象类</span></span><br><span class="line"><span class="comment">                3.接口怎么定义，语法是什么？</span></span><br><span class="line"><span class="comment">                public interface 接口名&#123;&#125;</span></span><br><span class="line"><span class="comment">                4.接口编译之后也是一个字节码文件.class</span></span><br><span class="line"><span class="comment">                5.接口支持多继承，一个接口允许继承多个接口</span></span><br><span class="line"><span class="comment">                6.接口中只包含两部分内容，一部分是：常量。一部分是：抽象方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//定义一个接口</span></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个接口</span></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">B</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接口支持多继承</span></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>,B&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-访问修饰符"><a href="#4-访问修饰符" class="headerlink" title="4.访问修饰符"></a>4.访问修饰符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问控制权限有4种</span></span><br><span class="line"><span class="comment">     * 1.private    私有的     表示私有的，只能在本类中访问</span></span><br><span class="line"><span class="comment">     * 2.protected  受保护的    表示只能在本类、同包、子类中访问</span></span><br><span class="line"><span class="comment">     * 3.public     公开的     表示公开的，在任何位置都可以访问</span></span><br><span class="line"><span class="comment">     * 4            默认的     默认只能在本类或者同包下访问</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 访问控制修饰符          本类      同包      子类      任意位置</span></span><br><span class="line"><span class="comment">     * -------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * public                可以      可以       可以       可以</span></span><br><span class="line"><span class="comment">     * private               可以      不行       不行       不行</span></span><br><span class="line"><span class="comment">     * protecte              可以      可以       可以       不行</span></span><br><span class="line"><span class="comment">     * 默认                   可以      可以       不行       不行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-重写toString方法"><a href="#5-重写toString方法" class="headerlink" title="5.重写toString方法"></a>5.重写toString方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyTime myTime;</span><br><span class="line">        myTime = <span class="keyword">new</span> <span class="title class_">MyTime</span>(<span class="number">2002</span>,<span class="number">04</span>,<span class="number">06</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span>  myTime.toString();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTime</span> &#123;</span><br><span class="line">        <span class="type">int</span> year;</span><br><span class="line">        <span class="type">int</span> month;</span><br><span class="line">        <span class="type">int</span> day;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MyTime</span><span class="params">()</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTime</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.year = year;</span><br><span class="line">            <span class="built_in">this</span>.month = month;</span><br><span class="line">            <span class="built_in">this</span>.day = day;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.year+<span class="string">&quot;年&quot;</span>+<span class="built_in">this</span>.month+<span class="string">&quot;月&quot;</span>+<span class="built_in">this</span>.day+<span class="string">&quot;日&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-equals方法的底层代码"><a href="#6-equals方法的底层代码" class="headerlink" title="6.equals方法的底层代码"></a>6.equals方法的底层代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.equals方法的源代码       equals方法使用&quot;==&quot;号来判断  要重写Object中的 equals方法</span></span><br><span class="line"><span class="comment">         * public boolean equals(Object obj)&#123;</span></span><br><span class="line"><span class="comment">         *  return (this == obj);</span></span><br><span class="line"><span class="comment">         *  &#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  equals的作用</span></span><br><span class="line"><span class="comment">         *  判断两个对象是否相等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断两个基本数据类型的数据是否相等使用&quot;==&quot;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        System.out.println(a==b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断两个对象时，使用equals方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-匿名内部类"><a href="#7-匿名内部类" class="headerlink" title="7.匿名内部类"></a>7.匿名内部类</h4><p><strong>1.什么是内部类</strong><br>      <strong>内部类：在类的内部又定义一个新的类，被称为内部类</strong><br><strong>2.内部类的分类</strong><br>       <strong>静态内部类：类似于静态变量</strong><br>       <strong>实例内部类：类似于实例变量</strong><br>       <strong>局部内部类：类似于局部变量</strong>** </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 匿名内部类：</span></span><br><span class="line"><span class="comment">         *  1.什么是内部类</span></span><br><span class="line"><span class="comment">         *  内部类：在类的内部又定义一个新的类，被称为内部类</span></span><br><span class="line"><span class="comment">         *  2.内部类的分类</span></span><br><span class="line"><span class="comment">         *      静态内部类：类似于静态变量</span></span><br><span class="line"><span class="comment">         *      实例内部类：类似于实例变量</span></span><br><span class="line"><span class="comment">         *      局部内部类：类似于局部变量</span></span><br><span class="line"><span class="comment">         *  3.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Test01</span>&#123;</span><br><span class="line">            <span class="comment">//静态内部类</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner1</span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//实例内部类</span></span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">Inner2</span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//局部内部类     匿名内部类</span></span><br><span class="line">                <span class="keyword">class</span> <span class="title class_">Inner3</span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础学习day04</title>
    <url>/2023/03/03/java%E5%AD%A6%E4%B9%A0%E7%AC%AC4%E5%A4%A9/</url>
    <content><![CDATA[<h4 id="1-try…catch异常处理"><a href="#1-try…catch异常处理" class="headerlink" title="1.try…catch异常处理"></a>1.try…catch异常处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    try....catch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\20计科2班\\数据结构实验\\排序实验\\sort.c&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;以上出现异常，这里无法执行。。。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已损坏或文件丢失&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-异常对象常用的两个方法"><a href="#2-异常对象常用的两个方法" class="headerlink" title="2.异常对象常用的两个方法"></a>2.异常对象常用的两个方法</h4><p><strong>exception.getMessage();</strong></p>
<p><strong>exception.printStackTrace();</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    异常对象有两个非常重要的方法：</span></span><br><span class="line"><span class="comment">    获取简单异常的描述信息</span></span><br><span class="line"><span class="comment">   exception.getMessage();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   打印异常追踪的堆栈信息：</span></span><br><span class="line"><span class="comment">   exception.printStackTrace();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NullPointerException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">        <span class="comment">//获取异常的信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> e.getMessage();</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="comment">//打印异常信息</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-FileNotFoundException异常"><a href="#3-FileNotFoundException异常" class="headerlink" title="3.FileNotFoundException异常"></a>3.FileNotFoundException异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里程序不耽误执行，很健壮。《服务器不会因为遇到异常而宕机》</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">     m3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">//此处文件路径不对</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\20计科2班\\操作系统实验\\chazhao.c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-finally子句"><a href="#4-finally子句" class="headerlink" title="4.finally子句"></a>4.finally子句</h4><p><strong>1.在finally子句中的代码是最后执行的，并且一定会执行的，即使try语句块中的代码出现了异常。finally子句必须和try一起出现不能单编写</strong><br><strong>2.finally语句块中的代码出现异常，finally中代码也会正常执行。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    关于try...catch的finally子句：</span></span><br><span class="line"><span class="comment">    1.在finally子句中的代码是最后执行的，并且一定会执行的，即使try语句块中的代码出现了异常。</span></span><br><span class="line"><span class="comment">    finally子句必须和try一起出现不能单编写</span></span><br><span class="line"><span class="comment">    2.finally语句块中的代码出现异常，finally中代码也会正常执行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\20计科2班\\操作系统实验\\二分查找\\chazhao.c&quot;</span>);</span><br><span class="line">            <span class="comment">//这里一定会出现空指针异常</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            s.toString();</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello，浩克&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-java面试题"><a href="#5-java面试题" class="headerlink" title="5.java面试题"></a>5.java面试题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> m();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    java语法规则（有一些规则是不能破坏的，一旦这么说了，就必须这么做！）：</span></span><br><span class="line"><span class="comment">        java中 有一条这样的规则：</span></span><br><span class="line"><span class="comment">            方法体中的代码必须遵循自上而下的顺序一次逐行执行（亘古不变的语法！）</span></span><br><span class="line"><span class="comment">        java中还有一条规则：</span></span><br><span class="line"><span class="comment">            return语句一旦执行，整个方法必须结束（亘古不变的语法！！！）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础学习day03</title>
    <url>/2023/03/03/java%E5%AD%A6%E4%B9%A0%E7%AC%AC3%E5%A4%A9/</url>
    <content><![CDATA[<h4 id="1-匿名内部类："><a href="#1-匿名内部类：" class="headerlink" title="1.匿名内部类："></a>1.匿名内部类：</h4><p><strong>可以直接实现接口，但没有名字复用性差，代码可读性差，不建议这样写</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyMath</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyMath</span>();</span><br><span class="line">        m.mySum(<span class="keyword">new</span> <span class="title class_">Compute</span>() &#123; <span class="comment">//匿名内部类     </span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> x+y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">200</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Compute</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyMath</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mySum</span><span class="params">(Compute c,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">retValue</span> <span class="operator">=</span> c.sum(x,y);</span><br><span class="line">            System.out.println(x+<span class="string">&quot;+&quot;</span>+y+<span class="string">&quot;=&quot;</span>+retValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-数组扩容"><a href="#2-数组扩容" class="headerlink" title="2.数组扩容"></a>2.数组扩容</h4><p><strong>java中的数组扩容，要先创建一个大数组，在将原数组的数据拷贝过去</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">//数组扩容，先创建一个大数组，在将原数组的数据拷贝过去</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//数组拷贝</span></span><br><span class="line"><span class="comment">//        System.arraycopy(5个参数);</span></span><br><span class="line">        <span class="comment">//拷贝源（从这个数组中进行拷贝）</span></span><br><span class="line">        <span class="type">int</span> [] src = &#123;<span class="number">1</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拷贝目标数组</span></span><br><span class="line">        <span class="type">int</span> [] dest = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20</span>];<span class="comment">//动态初始化长度为20的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用jdk中System.arraycopy()的方法</span></span><br><span class="line">        System.arraycopy(src,<span class="number">0</span>,dest,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;dest.length ; i++) &#123;</span><br><span class="line">            System.out.print(dest[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Arrays工具类"><a href="#3-Arrays工具类" class="headerlink" title="3.Arrays工具类"></a>3.Arrays工具类</h4><p><strong>Arrays是一个工具类。</strong></p>
<p><strong>在java.util.Arrays包下</strong></p>
<p><strong>其中有一个sort方法，可以排序。静态方法，直接使用类名调用就行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//java.util.Arrays</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Arrays是一个工具类。</span></span><br><span class="line"><span class="comment">         * 其中有一个sort方法，可以排序。静态方法，直接使用类名调用就行</span></span><br><span class="line"><span class="comment">         * 工具类当中的方法，大部分都是静态的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">5</span>,<span class="number">65</span>,<span class="number">26</span>,<span class="number">35</span>,<span class="number">15</span>,<span class="number">355</span>,<span class="number">662</span>,<span class="number">51</span>,<span class="number">121</span>,<span class="number">0</span>,<span class="number">23</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Arrays-binarySearch方法"><a href="#4-Arrays-binarySearch方法" class="headerlink" title="4.Arrays.binarySearch方法"></a>4.Arrays.binarySearch方法</h4><p><strong>此方法是在数组中判断是否有相同的值，有则返回该元素下标，没有则返回-1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//java.util.Arrays     工具类中有哪些方法，参考帮助文档</span></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">32</span>);</span><br><span class="line">        System.out.println(index==-<span class="number">1</span> ? <span class="string">&quot;该元素不存在&quot;</span>:<span class="string">&quot;该元素下标是:&quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-了解java的异常"><a href="#5-了解java的异常" class="headerlink" title="5.了解java的异常"></a>5.了解java的异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.什么是异常，java提供异常机制有什么用处？</span></span><br><span class="line"><span class="comment">    以下程序执行过程中发生了不正常的情况,而这种不正常的情况叫做：异常</span></span><br><span class="line"><span class="comment">    java语言是很完美的语言，提供了异常处理的方式，以下程序执行过程中出现了不正常的情况</span></span><br><span class="line"><span class="comment">    java把该异常信息打印输出到控制台，供程序员参考。</span></span><br><span class="line"><span class="comment">    2.以下程序执行控制台出现了：</span></span><br><span class="line"><span class="comment">                异常</span></span><br><span class="line"><span class="comment">    这个信息我们称为异常信息，这个信息是JVM打印的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//实际上JVM执行到此处的时候，会new异常对象：new ArithmeticException(&quot;/ by zero&quot;);</span></span><br><span class="line">        <span class="comment">//并且在JVM将new的异常对象抛出，打印输出信息到控制台了。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a/b;</span><br><span class="line">        System.out.println(a+<span class="string">&quot;/&quot;</span>+b+<span class="string">&quot;=&quot;</span>+c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-通过异常类去实例化异常对象"><a href="#6-通过异常类去实例化异常对象" class="headerlink" title="6.通过异常类去实例化异常对象"></a>6.通过异常类去实例化异常对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过异常类去实例化异常对象</span></span><br><span class="line">        <span class="type">NumberFormatException</span> <span class="variable">nfe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberFormatException</span>(<span class="string">&quot;数字格式化异常！！！&quot;</span>);</span><br><span class="line">        System.out.println(nfe);</span><br><span class="line">        <span class="type">NullPointerException</span> <span class="variable">npe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;空指针异常发生了！！！&quot;</span>);</span><br><span class="line">        System.out.println(npe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础学习day06</title>
    <url>/2023/03/03/java%E5%AD%A6%E4%B9%A0%E7%AC%AC6%E5%A4%A9/</url>
    <content><![CDATA[<h4 id="1-关于java-util-Collection接口中常用的方法"><a href="#1-关于java-util-Collection接口中常用的方法" class="headerlink" title="1.关于java.util.Collection接口中常用的方法"></a>1.关于java.util.Collection接口中常用的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    关于java.util.Collection接口中常用的方法</span></span><br><span class="line"><span class="comment">    boolean add(Object e)   添加元素</span></span><br><span class="line"><span class="comment">    int size()      获取元素个数</span></span><br><span class="line"><span class="comment">    void clear()    清空集合</span></span><br><span class="line"><span class="comment">    boolean contains(Object o)  判断当前集合中是否包含元素o</span></span><br><span class="line"><span class="comment">    boolean remove(Object o)    删除集合中的某个元素</span></span><br><span class="line"><span class="comment">    boolean isEmpty()           判断集合是否为空</span></span><br><span class="line"><span class="comment">    Object[] toArray()  调用这个方法可以把集合转换成数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//测试方法</span></span><br><span class="line">        collection.add(<span class="number">1200</span>);<span class="comment">//自动装箱,实际上是放进去了一个对象的内存地址。</span></span><br><span class="line">        collection.add(<span class="number">3.1415926535</span>);</span><br><span class="line">        collection.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        collection.add(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的元素个数是:&quot;</span>+collection.size());</span><br><span class="line">        collection.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的元素个数是:&quot;</span>+collection.size());</span><br><span class="line"></span><br><span class="line">        collection.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;浩克&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;绿巨人&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> collection.contains(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">remove</span> <span class="operator">=</span> collection.remove(<span class="string">&quot;绿巨人&quot;</span>);</span><br><span class="line">        System.out.println(remove);</span><br><span class="line">        System.out.println(collection.size());</span><br><span class="line">        System.out.println(collection.isEmpty());</span><br><span class="line"></span><br><span class="line">        collection.add(<span class="string">&quot;520&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;120&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;130&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;150&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//集合转成数组</span></span><br><span class="line"></span><br><span class="line">        Object[] objects = collection.toArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            System.out.println(objects[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-集合的迭代器"><a href="#2-集合的迭代器" class="headerlink" title="2.集合的迭代器"></a>2.集合的迭代器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    集合迭代器   集合遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意以下的遍历方式、迭代方式，是所有Collection通用的一种方式。</span></span><br><span class="line">        <span class="comment">//在Map集合中不能用，在所有的Collection以及子类中使用。</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        collection.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;132&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;580&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;a250&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;abc5656&quot;</span>);</span><br><span class="line">        collection.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对集合遍历、迭代</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一步：获取集合对象的迭代器对象</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line">        <span class="comment">//第二步：通过以上获取的迭代器对象开始遍历集合</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        boolean hasNext()   如果迭代具有更多元素，则返回 true 。</span></span><br><span class="line"><span class="comment">        Object next()    返回迭代中的下一个元素。</span></span><br><span class="line"><span class="comment">        default void remove()   从底层集合中删除此迭代器返回的最后一个元素（可选操作）。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-java如何获取到迭代器"><a href="#3-java如何获取到迭代器" class="headerlink" title="3.java如何获取到迭代器"></a>3.java如何获取到迭代器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        collection.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;520llo&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;123lo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取对象的迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//HashSet 无序    并且不可重复</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        collection1.add(<span class="number">123</span>);</span><br><span class="line">        collection1.add(<span class="number">321</span>);</span><br><span class="line">        collection1.add(<span class="number">100</span>);</span><br><span class="line">        collection1.add(<span class="number">200</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> collection1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础学习day05</title>
    <url>/2023/03/03/java%E5%AD%A6%E4%B9%A0%E7%AC%AC5%E5%A4%A9/</url>
    <content><![CDATA[<h4 id="1-如何自定义一个异常类"><a href="#1-如何自定义一个异常类" class="headerlink" title="1.如何自定义一个异常类"></a>1.如何自定义一个异常类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.sun公司提供的JDK内置的异常肯定是不够用的，在实际开发当中，有很多的业务，</span></span><br><span class="line"><span class="comment">这些业务出现异常之后，JDK中都是没有的。和业务挂钩的。那么异常类我们程序员可以自己定义吗</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.java中我怎么定义异常呢？</span></span><br><span class="line"><span class="comment">    两步：</span></span><br><span class="line"><span class="comment">        第一步：编写一个类继承Exception或者RuntimeException.</span></span><br><span class="line"><span class="comment">        第二步：提供两个构造方法，一个无参数的，一个带有String参数的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;<span class="comment">//编译时异常</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String s)</span>&#123;</span><br><span class="line">            <span class="built_in">super</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/* public class MyException extends RuntimeException&#123; //运行时异常</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-如何用自定义的异常类"><a href="#2-如何用自定义的异常类" class="headerlink" title="2.如何用自定义的异常类"></a>2.如何用自定义的异常类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        类在强制类型转换中，如果是类型转换成接口类型。</span></span><br><span class="line"><span class="comment">        那么类和接口之间不需要从在继承关系，也可以转换</span></span><br><span class="line"><span class="comment">        java语法中允许。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建异常对象（只创建了异常信息，并没有抛出）</span></span><br><span class="line">        Demo1.<span class="type">MyException</span> <span class="variable">myException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo1</span>.MyException(<span class="string">&quot;用户名不能为空&quot;</span>);</span><br><span class="line">        <span class="comment">//打印异常堆栈信息</span></span><br><span class="line">        myException.printStackTrace();</span><br><span class="line">        <span class="comment">//获取异常简单描述信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> myException.getMessage();</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-重写之后的方法不能比重写之前的方法抛出更多的异常，可以更少"><a href="#3-重写之后的方法不能比重写之前的方法抛出更多的异常，可以更少" class="headerlink" title="3.重写之后的方法不能比重写之前的方法抛出更多的异常，可以更少"></a>3.重写之后的方法不能比重写之前的方法抛出更多的异常，可以更少</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">重写之后的方法不能比重写之前的方法抛出更多的异常，可以更少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">//编译正常</span></span><br><span class="line">   <span class="comment">/* public void doSome() throws RuntimeException&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    编译报错</span></span><br><span class="line">    <span class="comment">/*public void doSome() throws Exception&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">//编译正常</span></span><br><span class="line">    <span class="comment">/*public void doOther()&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">//编译正常</span></span><br><span class="line">    <span class="comment">/*public void doOther() throws Exception&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">   <span class="comment">//编译正常</span></span><br><span class="line">   <span class="comment">/* public void doOther() throws NullPointerException &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-集合"><a href="#4-集合" class="headerlink" title="4.集合"></a>4.集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.集合概述</span></span><br><span class="line"><span class="comment"> *      1.1什么是集合？有什么用？</span></span><br><span class="line"><span class="comment"> *          数组其实就是一个集合。集合实际上就是一个容器。可以用来容纳其它类型的数据。</span></span><br><span class="line"><span class="comment"> *          集合为什么说是在开发中使用较多。</span></span><br><span class="line"><span class="comment"> *              集合是一个容器，是可以一次容纳多个对象</span></span><br><span class="line"><span class="comment"> *              在实际开发中，假设连接数据库，数据库中有10条记录，</span></span><br><span class="line"><span class="comment"> *              那么假设把这10条记录查询出来，然后将10个java对象放到某一个，</span></span><br><span class="line"><span class="comment"> *              集合当中，将集合传到前端，然后遍历集合，将一个数据一个数据展示出来。</span></span><br><span class="line"><span class="comment"> *       1.2集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，</span></span><br><span class="line"><span class="comment"> *       集合当中存储的都是java对象的内存地址。（或者说集合中存储的是引用）</span></span><br><span class="line"><span class="comment"> *       list.add(100);</span></span><br><span class="line"><span class="comment"> *       注意：</span></span><br><span class="line"><span class="comment"> *          集合在java中本身是一个容器，是一个对象。</span></span><br><span class="line"><span class="comment"> *          集合中任何时候存储的都是“引用”</span></span><br><span class="line"><span class="comment"> *       1.3在java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。</span></span><br><span class="line"><span class="comment"> *       什么是数据结构？数据存储的结构就是数据结构。不同的数据结构，数据存储的方式不同。例如：</span></span><br><span class="line"><span class="comment"> *       数组  二叉树  链表  哈希表...</span></span><br><span class="line"><span class="comment"> *       以上这些都是常见的数据结构。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       往集合c1中放数据，可能是放到数组上了</span></span><br><span class="line"><span class="comment"> *       往集合c2中放数据，可能是放到二叉树上了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       使用不同的集合等于使用了不同的数据结构</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       java中不需要精通数据结构。java中已经将数据结构实现，已经写好了这些常用的集合类</span></span><br><span class="line"><span class="comment"> *       在什么情况下使用什么数据结构。</span></span><br><span class="line"><span class="comment"> *       new ArrayList();创建一个集合，底层是数组</span></span><br><span class="line"><span class="comment"> *       new LinkedList();创建一个集合，底层是链表</span></span><br><span class="line"><span class="comment"> *       new  TreeSet();创建i一个集合，底层是二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       1.4、集合在JDK的那个包下？</span></span><br><span class="line"><span class="comment"> *          java.util.*;</span></span><br><span class="line"><span class="comment"> *          所有的集合类和集合接口都在java.util包下;</span></span><br><span class="line"><span class="comment"> *       总结（所有的实现类）：</span></span><br><span class="line"><span class="comment"> *       ArrayList:底层数据结构是数组</span></span><br><span class="line"><span class="comment"> *       LinkedList:底层数据结构是双向链表</span></span><br><span class="line"><span class="comment"> *       Vector:底层数据结构是数组，线程安全的，效率较低，使用较少</span></span><br><span class="line"><span class="comment"> *       HashMap:底层数据结构是哈希表</span></span><br><span class="line"><span class="comment"> *       HashSet:底层数据结构是HashMap,放到HashSet集合中的元素等同于放到HashMap集合Key部分了</span></span><br><span class="line"><span class="comment"> *       Hashtable:底层数据结构是哈希表，是线程安全的，效率较低，使用较少</span></span><br><span class="line"><span class="comment"> *       Properties:是线程安全的，并且key和vaule是String类型的</span></span><br><span class="line"><span class="comment"> *       TreeSet:底层数据结构是TreeMap,放到TreeSet集合中的元素等同于放到TreeMap集合Key部分了。</span></span><br><span class="line"><span class="comment"> *       TreeMap:底层是二叉树数据结构。TreeMap集合的key可以按照大小排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    List 集合存储元素的特点：</span></span><br><span class="line"><span class="comment">        有序可重复</span></span><br><span class="line"><span class="comment">        有序：存进去的顺序和取出来的顺序是相同的，元素有下标</span></span><br><span class="line"><span class="comment">        可重复：存进去1，还可以存1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Set集合存储元素的特点：</span></span><br><span class="line"><span class="comment">        无序不可重复</span></span><br><span class="line"><span class="comment">        无序：存进去的顺序和取出来的顺序不一定相同。另为Set集合中元素没有下标。</span></span><br><span class="line"><span class="comment">        不可重复：存进去1，不能在存1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    SortedSet集合存储元素的特点：</span></span><br><span class="line"><span class="comment">        首先是无序不可重复的，但是SortedSet集合中的元素是可排序的。</span></span><br><span class="line"><span class="comment">        无序：存进去和取出来的顺序不一定相同。另外Set集合中元素没有下标</span></span><br><span class="line"><span class="comment">        不可重复：存进去1，不能再存储1；</span></span><br><span class="line"><span class="comment">        可排序：可以按照大小排序；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Map集合的Key，就是一个Set集合。</span></span><br><span class="line"><span class="comment">        往Set集合中放数据，实际上放到了Map集合的Key部分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个课后作业："><a href="#两个课后作业：" class="headerlink" title="两个课后作业："></a>两个课后作业：</h2><h4 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeWork</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入用户名（要求大于6位，小于14位）：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userService.register(username,password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HomeWork1.MyException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String username,String password)</span> <span class="keyword">throws</span> HomeWork1.MyException &#123;</span><br><span class="line">            <span class="keyword">if</span> (username.length()&gt;<span class="number">6</span>&amp;&amp;username.length()&lt;<span class="number">14</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;用户注册成功!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (username.length()&lt;<span class="number">6</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HomeWork1</span>.MyException(<span class="string">&quot;用户名小于6位，注册失败！！！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (username.length()&gt;<span class="number">14</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HomeWork1</span>.MyException(<span class="string">&quot;用户名大于14位，注册失败！！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeWork1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>  <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span>  <span class="title function_">MyException</span><span class="params">(String a)</span>&#123;</span><br><span class="line">            <span class="built_in">super</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础学习day09</title>
    <url>/2023/03/03/java%E5%AD%A6%E4%B9%A0%E7%AC%AC9%E5%A4%A9/</url>
    <content><![CDATA[<h4 id="1-静态内部类"><a href="#1-静态内部类" class="headerlink" title="1.静态内部类"></a>1.静态内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="comment">//声明一个静态内部类</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">       <span class="comment">//静态方法</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;静态内部类的m1方法执行&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//实例方法要创建对象</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;静态内部类中的实例方法执行&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Demo1.InnerClass.m1();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Map集合的遍历"><a href="#2-Map集合的遍历" class="headerlink" title="2.Map集合的遍历"></a>2.Map集合的遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jdi.Value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Map集合的遍历</span></span><br><span class="line"><span class="comment">        1.获取所有的Key，通过遍历Key，来遍历value</span></span><br><span class="line"><span class="comment">        2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取所有的Key，通过遍历Key，来遍历value</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>,<span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">        <span class="comment">//先获取所有的Key，所有的Key是Set集合</span></span><br><span class="line">        Set&lt;Integer&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">//遍历Key，通过Key获取Value</span></span><br><span class="line">        <span class="comment">//迭代器</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line">            System.out.println(map.get(iterator.next()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//增强for循环也可以</span></span><br><span class="line">        <span class="keyword">for</span> (Integer integer:keys) &#123;</span><br><span class="line">            System.out.println(map.get(integer));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方式Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span></span><br><span class="line">        <span class="comment">//以上这个方式是吧，Map集合直接全部转换成Set集合</span></span><br><span class="line">        <span class="comment">//Set集合中的元素类型是：Map.Entry</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator1 = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础学习day07</title>
    <url>/2023/03/03/java%E5%AD%A6%E4%B9%A0%E7%AC%AC7%E5%A4%A9/</url>
    <content><![CDATA[<h4 id="1-集合迭代器使用小技巧"><a href="#1-集合迭代器使用小技巧" class="headerlink" title="1.集合迭代器使用小技巧"></a>1.集合迭代器使用小技巧</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用迭代器的时候不能用remove方法，会改变集合的结构</span></span><br><span class="line"><span class="comment">        会报错</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        collection.add(<span class="number">1230</span>);</span><br><span class="line">        collection.add(<span class="number">2030</span>);</span><br><span class="line">        collection.add(<span class="number">1530</span>);</span><br><span class="line">        collection.add(<span class="number">1230</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line"><span class="comment">//        collection.remove(1230);</span></span><br><span class="line">        <span class="comment">//可以用迭代器的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除的一定是迭代器指向的当前元素</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(collection.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-List集合方法中的接口"><a href="#2-List集合方法中的接口" class="headerlink" title="2.List集合方法中的接口"></a>2.List集合方法中的接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试List方法接口中的常用方法</span></span><br><span class="line"><span class="comment">    1.List集合存储元素特点</span></span><br><span class="line"><span class="comment">        有序可重复：List集合元素有下标</span></span><br><span class="line"><span class="comment">        从0开始以1递增</span></span><br><span class="line"><span class="comment">    2.List接口中特有的方法</span></span><br><span class="line"><span class="comment">    void add(int index, E element) 将指定的元素插入此列表中的指定位置</span></span><br><span class="line"><span class="comment">    Object get(int index)  返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">    int indexOf(Object o)  返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</span></span><br><span class="line"><span class="comment">    int lastIndexOf(Object o)   返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。</span></span><br><span class="line"><span class="comment">    Object remove(int index)   删除该列表中指定位置的元素</span></span><br><span class="line"><span class="comment">    E set(int index, E element) 用指定的元素（可选操作）替换此列表中指定位置的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java进阶--深入理解Java自动装箱拆箱机制</title>
    <url>/2023/05/30/java%E8%BF%9B%E9%98%B6--%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%E6%9C%BA%E5%88%B6%EF%BC%88Autoboxing%20and%20unboxing%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、自动装箱与拆箱的定义"><a href="#一、自动装箱与拆箱的定义" class="headerlink" title="一、自动装箱与拆箱的定义"></a>一、自动装箱与拆箱的定义</h3><p>ava中的基本数据类型有八种分别是：int（4字节） byte（1字节） short（2字节） long（8字节） float （4字节） double（8字节） char（2字节） boolean（1byte）基本数据类型不是对象，不能使用对象的方法。将基本数据类型转换为对象就是自动装箱的过程。下面是基本数据类型与封装器类之间对应的关系。</p>
<table>
<thead>
<tr>
<th>简单类型</th>
<th>二进制位数</th>
<th>封装器类</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>32</td>
<td>Integer</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>float</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h4 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h4><p>先看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//定义一个基本数据类型的变量a赋值3</span></span><br><span class="line">        Integer b=a;</span><br><span class="line">        <span class="comment">//b是Integer 类定义的对象，直接用int 类型的a赋值    </span></span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">//打印结果为3</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中 Integer b&#x3D;a; 非常的奇怪，一个对象怎么赋值成了基本数据类型的变量，其实这就是自动装箱的过程，上面程序在执行Integer b&#x3D;a;的时候调用了Integer.valueOf ( int i ) 方法，&#96;Integer b&#x3D;a; 这段代码等同于：Integer b&#x3D;Integer.valueOf ( a ) 。下面是对 Integer.valueOf ( int i ) 方法简化后的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;       </span><br><span class="line">        <span class="keyword">if</span> (i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= <span class="number">127</span>)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">127</span>];</span><br><span class="line">            <span class="comment">//如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">        <span class="comment">//否则返回 new 一个Integer 对象</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Integer.valueOf ( a )其实是返回了一个Integer的对象。因此由于自动装箱的存在Integer b&#x3D;a 这段代码是没有毛病的。其实更简化的来写可以这样：Integer b&#x3D;3，同样这段代码等价于：Integer b&#x3D;Integer.valueOf (3 ) 。</p>
<h4 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h4><p>先看下面的这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        Integer b=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//b为Integer的对象</span></span><br><span class="line">        <span class="type">int</span> a=b;</span><br><span class="line">        <span class="comment">//a为一个int的基本数据类型</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="comment">//打印输出3。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码：int a&#x3D;b,很奇怪，怎么把一个对象赋给了一个基本类型呢？其实 int a&#x3D;b,这段代码等价于：int a&#x3D;b.intValue(),来看看inValue()方法到底是什么，下面是源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单嘛，就是返回了value值，然而value又是什么，继续找到了一个代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>原来value，就是定义 Integer b&#x3D;new Integer(3) ; 赋的值。所以上面的代码其实是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        Integer b=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//b为Integer的对象</span></span><br><span class="line">        <span class="type">int</span> a=b.intValue();</span><br><span class="line">        <span class="comment">//其中b.intValue()返回实例化b时构造函数new Integer(3);赋的值3。</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="comment">//打印输出3。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h4><p>自动装箱和拆箱已经解决了，看看下面的代码输出什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        Integer a=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">        Integer b=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">        System.out.println(a==b);<span class="comment">//输出 false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 </span></span><br><span class="line">        Integer c=<span class="number">123</span>;</span><br><span class="line">        Integer d=<span class="number">123</span>;  </span><br><span class="line">        System.out.println(c==d);<span class="comment">//输出 true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line">        Integer e=<span class="number">129</span>;</span><br><span class="line">        Integer f=<span class="number">129</span>;</span><br><span class="line">        System.out.println(e==f);<span class="comment">//输出 false</span></span><br><span class="line">        <span class="comment">//4</span></span><br><span class="line">        <span class="type">int</span> g=<span class="number">59</span>;</span><br><span class="line">        Integer h=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">59</span>);</span><br><span class="line">        System.out.println(g==h);<span class="comment">//输出 true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单一句话：<strong>装箱就是自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。</strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础学习day08</title>
    <url>/2023/03/03/java%E5%AD%A6%E4%B9%A0%E7%AC%AC8%E5%A4%A9/</url>
    <content><![CDATA[<h4 id="1-如何将线程不安全的ArrayList集合转为线程安全的"><a href="#1-如何将线程不安全的ArrayList集合转为线程安全的" class="headerlink" title="1.如何将线程不安全的ArrayList集合转为线程安全的"></a>1.如何将线程不安全的ArrayList集合转为线程安全的</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Vector:</span></span><br><span class="line"><span class="comment">        1.底层也是一个数组</span></span><br><span class="line"><span class="comment">        2.初始化容量：10</span></span><br><span class="line"><span class="comment">        3.扩容之后是原来容量的2倍</span></span><br><span class="line"><span class="comment">        4.ArrayList集合扩容是原来的1.5倍</span></span><br><span class="line"><span class="comment">        5.Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的。效率较低，较少使用。</span></span><br><span class="line"><span class="comment">        6.怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？</span></span><br><span class="line"><span class="comment">            java.util.Collections</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            java.util.Collection是接口</span></span><br><span class="line"><span class="comment">            java.util.Collections</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        6.怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？</span></span><br><span class="line"><span class="comment">            java.util.Collections</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            java.util.Collection是接口</span></span><br><span class="line"><span class="comment">            java.util.Collections</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//非线程安全</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//变为线程安全的</span></span><br><span class="line">        Collections.synchronizedList(list);</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="number">153</span>);</span><br><span class="line">        list.add(<span class="number">321</span>);</span><br><span class="line">        list.add(<span class="number">852</span>);</span><br><span class="line">        list.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-泛型机制"><a href="#2-泛型机制" class="headerlink" title="2.泛型机制"></a>2.泛型机制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用JDK5之后的泛型机制</span></span><br><span class="line"><span class="comment">    泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。</span></span><br><span class="line"><span class="comment">    使用泛型机制的好处是什么？</span></span><br><span class="line"><span class="comment">        第一：集合中存储的元素类型统一。</span></span><br><span class="line"><span class="comment">        第二：从集合中取出来的元素类型是泛型指定的类型，不需要进行大量的&quot;向下转型&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    泛型机制的缺点是什么？</span></span><br><span class="line"><span class="comment">        导致集合中存储的元素缺乏多样性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        <span class="comment">//使用泛型机制List&lt;Animal&gt;之后，表示List集合中只允许存储Animal类型的数据。</span></span><br><span class="line">        List&lt;Animal&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">        <span class="comment">//存储其他类型的数据就会编译报错</span></span><br><span class="line">        list.add(cat);</span><br><span class="line">        list.add(bird);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Animal&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"><span class="comment">//            animal.move();</span></span><br><span class="line">            <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">                <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> (Cat) animal;</span><br><span class="line">                cat1.catchMouse();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Bird)&#123;</span><br><span class="line">                <span class="type">Bird</span> <span class="variable">bird1</span> <span class="operator">=</span> (Bird) animal;</span><br><span class="line">                bird1.fly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;动物在移动！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;猫抓老鼠!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;鸟儿在飞翔！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-自动类型推断、钻石表达式"><a href="#3-自动类型推断、钻石表达式" class="headerlink" title="3.自动类型推断、钻石表达式"></a>3.自动类型推断、钻石表达式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    自动类型推断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//自动类型判断，前提是JDK8之后才可以。</span></span><br><span class="line">        <span class="comment">//钻石表达式</span></span><br><span class="line">        List&lt;Demo2.Animal&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Demo2</span>.Animal());</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Demo2</span>.Cat());</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Demo2</span>.Bird());</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Demo2.Animal&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Demo2.<span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            animal.move();</span><br><span class="line">            System.out.println(animal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-如何自定义泛型"><a href="#4-如何自定义泛型" class="headerlink" title="4.如何自定义泛型"></a>4.如何自定义泛型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  可以自定义泛型吗？</span></span><br><span class="line"><span class="comment">  可以的哦，亲；</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &lt;admin&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">(admin admin)</span>&#123;</span><br><span class="line">        System.out.println(admin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Demo4 &lt;String&gt; demo4 = <span class="keyword">new</span> <span class="title class_">Demo4</span>&lt;&gt;();</span><br><span class="line">        demo4.doSome(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        Demo4 &lt;Integer&gt; demo41 = <span class="keyword">new</span> <span class="title class_">Demo4</span>&lt;&gt;();</span><br><span class="line">        demo41.doSome(<span class="number">123</span>);</span><br><span class="line">        MyIterator &lt;String&gt; myIterator = <span class="keyword">new</span> <span class="title class_">MyIterator</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> myIterator.get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyIterator</span> &lt;T&gt;&#123;</span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-增强for循环foreach"><a href="#5-增强for循环foreach" class="headerlink" title="5.增强for循环foreach"></a>5.增强for循环foreach</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    JDk5.0之后推出了一个新特性，叫做增强for循环，或者叫做foreach</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//int类型数据</span></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">434</span>,<span class="number">56</span>,<span class="number">25</span>,<span class="number">16</span>,<span class="number">353</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="comment">//遍历数组(普通for循环)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length ; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增强for循环(foreach)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (元素类型 变量名: 数组或集合) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(变量名);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">//        foreach没有下标（缺点）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-用foreach遍历集合"><a href="#6-用foreach遍历集合" class="headerlink" title="6.用foreach遍历集合"></a>6.用foreach遍历集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    集合使用foreach</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建List集合</span></span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        strings.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;tong&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;tong&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s:strings) &#123;    <span class="comment">//因为泛型使用的是String</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-TreeSet集合"><a href="#7-TreeSet集合" class="headerlink" title="7.TreeSet集合"></a>7.TreeSet集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo7</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    TreeSet集合存储元素的特点:</span></span><br><span class="line"><span class="comment">        1.无序不可重复，但是存储的元素可以自动按照大小排序</span></span><br><span class="line"><span class="comment">        称为：可排序集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Set集合</span></span><br><span class="line">        Set&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        strings.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;K&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s:strings) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从小到大排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-Map集合"><a href="#8-Map集合" class="headerlink" title="8.Map集合"></a>8.Map集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo8</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.Map接口中常用的方法：</span></span><br><span class="line"><span class="comment">        1.Map和Collection没有继承关系。</span></span><br><span class="line"><span class="comment">        2.Map集合已Key和Value的方式存储数据，键值对</span></span><br><span class="line"><span class="comment">            key 和 value都是引用数据类型。</span></span><br><span class="line"><span class="comment">            key 和  value都是存储对象的内存地址</span></span><br><span class="line"><span class="comment">            key起到主导的地位，value是key的一个附属品</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3.Map接口中的常用方法</span></span><br><span class="line"><span class="comment">        V put(K key, V value)   向Map中添加键值对</span></span><br><span class="line"><span class="comment">        V get(Object key)    判断Map中是否包含某个Key</span></span><br><span class="line"><span class="comment">        void clear()    清空Map集合</span></span><br><span class="line"><span class="comment">        boolean containsKey(Object key)     如果此映射包含指定键的映射，则返回 true 。</span></span><br><span class="line"><span class="comment">        boolean containsValue(Object value)     判断Map中是否包含某个Value</span></span><br><span class="line"><span class="comment">        boolean isEmpty()   判断Map集合中的元素个数是否为0</span></span><br><span class="line"><span class="comment">        Set&lt;K&gt; keySet()     获取Map所有的Key</span></span><br><span class="line"><span class="comment">        V remove(Object key)    删除对应Key的</span></span><br><span class="line"><span class="comment">        int size()  获取Map集合中键值对的个数</span></span><br><span class="line"><span class="comment">        Collection&lt;V&gt; values()  获取Map集合中所有的value，返回一个Collection</span></span><br><span class="line"><span class="comment">        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()  将Map集合转换成Set集合</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        Map&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//向Map集合中添加键值对</span></span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>,<span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">       <span class="comment">//通过Key获取value</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span>  map.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">//获取键值对的数量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;键值对的数量：&quot;</span>+map.size());</span><br><span class="line">        <span class="comment">//通过key删除key-value</span></span><br><span class="line">        map.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;键值对的数量：&quot;</span>+map.size());</span><br><span class="line">        <span class="comment">//判断是否包含某个Key</span></span><br><span class="line">        <span class="comment">//contains方法底层调用的都是equals进行对比，所以自定义的类型需要重写equals方法</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">//判断是否包含某个value</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="string">&quot;wangwu&quot;</span>));</span><br><span class="line">        <span class="comment">//获取所有的Value</span></span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String s:values) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清空Map集合</span></span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;键值对的数量：&quot;</span>+map.size());</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title>public class和class的区别</title>
    <url>/2023/09/08/public%20class%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="public-class和class的区别："><a href="#public-class和class的区别：" class="headerlink" title="public class和class的区别："></a>public class和class的区别：</h2><ul>
<li>一个java源文件当中可以定义多个class</li>
<li>一个java源文件当中public的class不是必须的</li>
<li>一个class会定义生成一个xxx.class字节码文件</li>
<li>一个java源文件当中定义公开的类的话，公开类只能有一个，并且该类名称必须和java源文件名称一致。</li>
<li>每一个class当中都可以编写main方法，都可以设定程序的入口，想执行B.class的main方法：java B，想执行X.class当中的main方法：java X</li>
<li>注意：当在命令窗口中执行java Hello，那么要求Hello.class当中必须有主方法。没有主方法会出现运行阶段的错误。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务框架学习day1</title>
    <url>/2023/06/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%AC1%E5%A4%A9/</url>
    <content><![CDATA[<h2 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h2><h5 id="单体架构-将业务的所有功能集中在一个项目中开发，打成一个包部署。"><a href="#单体架构-将业务的所有功能集中在一个项目中开发，打成一个包部署。" class="headerlink" title="单体架构:将业务的所有功能集中在一个项目中开发，打成一个包部署。"></a>单体架构:将业务的所有功能集中在一个项目中开发，打成一个包部署。</h5><p>优点：</p>
<ol>
<li>架构简单</li>
<li>部署成本低</li>
</ol>
<p>缺点：</p>
<ol>
<li>耦合度高</li>
</ol>
<h5 id="分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。"><a href="#分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。" class="headerlink" title="分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。"></a>分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。</h5><p>优点：</p>
<ol>
<li>降低耦合度</li>
<li>有利于服务升级拓展</li>
</ol>
<h5 id="微服务：微服务是一种经过良好的架构设计的分布式架构方案，微服务架构特征："><a href="#微服务：微服务是一种经过良好的架构设计的分布式架构方案，微服务架构特征：" class="headerlink" title="微服务：微服务是一种经过良好的架构设计的分布式架构方案，微服务架构特征："></a>微服务：微服务是一种经过良好的架构设计的分布式架构方案，微服务架构特征：</h5><ol>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发</li>
<li>面向服务：微服务对外暴露业务接口</li>
<li>自治：团队独立、技术独立、部署独立、数据独立。</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联错误。</li>
</ol>
<h2 id="2-服务拆分及远程调用"><a href="#2-服务拆分及远程调用" class="headerlink" title="2.服务拆分及远程调用"></a>2.服务拆分及远程调用</h2><ul>
<li><h5 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h5><ol>
<li>不同微服务，不要重复开发相同业务</li>
<li>微服务数据独立，不要访问其它微服务的数据库</li>
<li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li>
</ol>
</li>
<li><h5 id="服务间调用"><a href="#服务间调用" class="headerlink" title="服务间调用"></a>服务间调用</h5><ol>
<li>远程调用方式分析<ul>
<li>调用接口需要请求，ajax可以发送请求，浏览器也可以发送请求，但是模块之间不能相互请求</li>
<li>使用RsetTemplate解决模块之间不能请求的问题</li>
<li>基于RestTemplate发起的http请求实现远程调用</li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	SpringApplication.run(OrderApplication.class,args);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *	创建RestTemplate并注入Spring容器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> RestTemplate restTemplate（）&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>（）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-提供者与消费者"><a href="#3-提供者与消费者" class="headerlink" title="3.提供者与消费者"></a>3.提供者与消费者</h2><ul>
<li>服务提供者：一次业务中，被其它微服务调用的服务。(提供接口给其它微服务)</li>
<li>服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</li>
</ul>
<ol>
<li>服务调用关系<ul>
<li>服务提供者：暴露接口给其他微服务调用</li>
<li>服务消费者：调用其它微服务提供的接口</li>
<li>提供者与消费者角色其实是相对的</li>
<li>一个服务既可以是消费者，又可以是提供者。</li>
</ul>
</li>
</ol>
<h2 id="4-Eureka注册中心"><a href="#4-Eureka注册中心" class="headerlink" title="4.Eureka注册中心"></a>4.Eureka注册中心</h2><ul>
<li><p>服务消费者该怎么样去获取到提供者的地址信息？</p>
<p>根据eureka注册中心</p>
</li>
<li><p>如果有多个服务提供者，消费者该如何选择？</p>
<p>根据负载均衡</p>
</li>
<li><p>消费者如何得知服务提供者的健康状态？</p>
<p>心跳续约，每30秒1次(如果有心跳就进行续约，如果没有心跳则取消此地址的引用)</p>
<p><strong>Eureka的作用：</strong></p>
<ol>
<li>注册服务信息：消费者和提供者(提供者会成为其他提供者的消费者)启动时会将信息保存到eureka注册中心(eureka-server)</li>
<li>拉取服务：消费者向eureka注册中心获取提供者的信息</li>
<li>负载均衡：根据负载均衡，选择一个地址</li>
<li>远程调用：根据选出的地址发送请求</li>
</ol>
<p>在Eureka架构中，微服务角色有两类：</p>
<ul>
<li><p>EurekaServer：服务端，注册中心</p>
<ul>
<li>记录服务信息</li>
<li>心跳监控</li>
</ul>
</li>
<li><p>EurekaClient：客户端</p>
<ul>
<li><p>Provider：服务提供者</p>
<ul>
<li>注册自己的信息到EurekaServer</li>
<li>每隔30秒向EurekaServer发送心跳</li>
</ul>
</li>
<li><p>consumer：消费者</p>
<ul>
<li>根据服务名称从EurekaServer拉取服务列表</li>
<li>基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>服务注册<ul>
<li>引入eureka-client依赖</li>
<li>在application.yml配置eureka地址</li>
</ul>
</li>
<li>无论是消费者还是提供者，引入eureka-client依赖、知道eureka地址后，都可以完成服务注册</li>
</ol>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>分布式应用-微服务</tag>
      </tags>
  </entry>
</search>
